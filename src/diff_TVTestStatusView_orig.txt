diff TVTestStatusView_orig/Aero.cpp ./Aero.cpp
1c1
< #include "stdafx.h"
---
> #include <Windows.h>
8d7
< #include <dwmapi.h>
25,105d23
< typedef HRESULT (WINAPI *DwmExtendFrameIntoClientAreaFunc)(HWND hWnd,const MARGINS *pMarInset);
< typedef HRESULT (WINAPI *DwmIsCompositionEnabledFunc)(BOOL *pfEnabled);
< typedef HRESULT (WINAPI *DwmEnableCompositionFunc)(UINT uCompositionAction);
< typedef HRESULT (WINAPI *DwmSetWindowAttributeFunc)(HWND hwnd,DWORD dwAttribute,LPCVOID pvAttribute,DWORD cbAttribute);
< 
< 
< CAeroGlass::CAeroGlass()
< 	: m_hDwmLib(NULL)
< {
< }
< 
< 
< CAeroGlass::~CAeroGlass()
< {
< 	if (m_hDwmLib)
< 		::FreeLibrary(m_hDwmLib);
< }
< 
< 
< bool CAeroGlass::LoadDwmLib()
< {
< 	if (m_hDwmLib==NULL) {
< 		m_hDwmLib=::LoadLibrary(TEXT("dwmapi.dll"));
< 		if (m_hDwmLib==NULL)
< 			return false;
< 	}
< 	return true;
< }
< 
< 
< // コンポジションが有効か取得する
< bool CAeroGlass::IsEnabled()
< {
< 	if (!LoadDwmLib())
< 		return false;
< 
< 	DwmIsCompositionEnabledFunc pIsCompositionEnabled;
< 	ProcAddress(pIsCompositionEnabled,m_hDwmLib,"DwmIsCompositionEnabled");
< 	BOOL fEnabled;
< 	return pIsCompositionEnabled!=NULL
< 		&& pIsCompositionEnabled(&fEnabled)==S_OK && fEnabled;
< }
< 
< 
< // クライアント領域を透けさせる
< bool CAeroGlass::ApplyAeroGlass(HWND hwnd,const RECT *pRect)
< {
< 	if (!IsEnabled())
< 		return false;
< 
< 	DwmExtendFrameIntoClientAreaFunc pExtendFrame;
< 	if (!ProcAddress(pExtendFrame,m_hDwmLib,"DwmExtendFrameIntoClientArea"))
< 		return false;
< 
< 	MARGINS Margins;
< 
< 	Margins.cxLeftWidth=pRect->left;
< 	Margins.cxRightWidth=pRect->right;
< 	Margins.cyTopHeight=pRect->top;
< 	Margins.cyBottomHeight=pRect->bottom;
< 	return pExtendFrame(hwnd,&Margins)==S_OK;
< }
< 
< 
< // フレームの描画を無効にする
< bool CAeroGlass::EnableNcRendering(HWND hwnd,bool fEnable)
< {
< 	if (!LoadDwmLib())
< 		return false;
< 
< 	DwmSetWindowAttributeFunc pSetWindowAttribute;
< 	if (!ProcAddress(pSetWindowAttribute,m_hDwmLib,"DwmSetWindowAttribute"))
< 		return false;
< 
< 	DWMNCRENDERINGPOLICY ncrp=fEnable?DWMNCRP_USEWINDOWSTYLE:DWMNCRP_DISABLED;
< 	return pSetWindowAttribute(hwnd,DWMWA_NCRENDERING_POLICY,&ncrp,sizeof(ncrp))==S_OK;
< }
< 
< 
< 
< 
126c44
< 				TRACE(TEXT("BufferedPaintInit() Failed\n"));
---
> 				//TRACE(TEXT("BufferedPaintInit() Failed\n"));
222,243d139
< }
< 
< 
< 
< 
< void CDoubleBufferingDraw::OnPaint(HWND hwnd)
< {
< 	::PAINTSTRUCT ps;
< 	::BeginPaint(hwnd,&ps);
< 	{
< 		CBufferedPaint BufferedPaint;
< 		RECT rc;
< 		::GetClientRect(hwnd,&rc);
< 		HDC hdc=BufferedPaint.Begin(ps.hdc,&rc);
< 		if (hdc!=NULL) {
< 			Draw(hdc,ps.rcPaint);
< 			BufferedPaint.End();
< 		} else {
< 			Draw(ps.hdc,ps.rcPaint);
< 		}
< 	}
< 	::EndPaint(hwnd,&ps);
diff TVTestStatusView_orig/Aero.h ./Aero.h
4,18d3
< 
< class CAeroGlass
< {
< public:
< 	CAeroGlass();
< 	~CAeroGlass();
< 	bool IsEnabled();
< 	bool ApplyAeroGlass(HWND hwnd,const RECT *pRect);
< 	bool EnableNcRendering(HWND hwnd,bool fEnable);
< 
< private:
< 	HMODULE m_hDwmLib;
< 	bool LoadDwmLib();
< };
< 
35,42d19
< 
< class CDoubleBufferingDraw
< {
< public:
< 	virtual void Draw(HDC hdc,const RECT &PaintRect) = 0;
< 	void OnPaint(HWND hwnd);
< };
< 
diff TVTestStatusView_orig/BasicWindow.cpp ./BasicWindow.cpp
1,2c1,3
< #include "stdafx.h"
< #include "TVTest.h"
---
> #include <Windows.h>
> #include <WindowsX.h>
> #include "Util.h"
diff TVTestStatusView_orig/ColorScheme.cpp ./ColorScheme.cpp
1,4c1,3
< #include "stdafx.h"
< #include <algorithm>
< #include "TVTest.h"
< #include "AppMain.h"
---
> #include <Windows.h>
> #include <string>
> #include "Util.h"
7,9d5
< #include "DialogUtil.h"
< #include "DrawUtil.h"
< #include "resource.h"
16a13
> #define lengthof _countof
45d41
< 	{HEXRGB(0xCCCCCC),	TEXT("Splitter"),							TEXT("分割線")},
47,190d42
< 	{HEXRGB(0x666666),	TEXT("PanelBack"),							TEXT("パネル背景")},
< 	{HEXRGB(0xCCCCCC),	TEXT("PanelText"),							TEXT("パネル文字")},
< 	{HEXRGB(0xCCCCCC),	TEXT("PanelTabBack"),						TEXT("パネルタブ背景1")},
< 	{HEXRGB(0x888888),	TEXT("PanelTabBack2"),						TEXT("パネルタブ背景2")},
< 	{HEXRGB(0x444444),	TEXT("PanelTabText"),						TEXT("パネルタブ文字")},
< 	{HEXRGB(0x444444),	TEXT("PanelTabBorder"),						TEXT("パネルタブ外枠")},
< 	{HEXRGB(0x999999),	TEXT("PanelCurTabBack"),					TEXT("パネル選択タブ背景1")},
< 	{HEXRGB(0x666666),	TEXT("PanelCurTabBack2"),					TEXT("パネル選択タブ背景2")},
< 	{HEXRGB(0xEEEEEE),	TEXT("PanelCurTabText"),					TEXT("パネル選択タブ文字")},
< 	{HEXRGB(0x444444),	TEXT("PanelCurTabBorder"),					TEXT("パネル選択タブ外枠")},
< 	{HEXRGB(0x888888),	TEXT("PanelTabMargin"),						TEXT("パネルタブ余白1")},
< 	{HEXRGB(0x888888),	TEXT("PanelTabMargin2"),					TEXT("パネルタブ余白2")},
< 	{HEXRGB(0x888888),	TEXT("PanelTabMarginBorder"),				TEXT("パネルタブ余白外枠")},
< 	{HEXRGB(0x444444),	TEXT("PanelTabLine"),						TEXT("パネルタブ線")},
< 	{HEXRGB(0x777777),	TEXT("PanelTitleBack"),						TEXT("パネルタイトル背景1")},
< 	{HEXRGB(0x222222),	TEXT("PanelTitleBack2"),					TEXT("パネルタイトル背景2")},
< 	{HEXRGB(0xBBBBBB),	TEXT("PanelTitleText"),						TEXT("パネルタイトル文字")},
< 	{HEXRGB(0x777777),	TEXT("PanelTitleBorder"),					TEXT("パネルタイトル外枠")},
< 	{HEXRGB(0x777777),	TEXT("ProgramInfoBack"),					TEXT("情報パネル番組背景")},
< 	{HEXRGB(0xDDDDDD),	TEXT("ProgramInfoText"),					TEXT("情報パネル番組文字")},
< 	{HEXRGB(0x777777),	TEXT("ProgramListBack"),					TEXT("番組表パネル番組内容背景1")},
< 	{HEXRGB(0x888888),	TEXT("ProgramListBack2"),					TEXT("番組表パネル番組内容背景2")},
< 	{HEXRGB(0xDDDDDD),	TEXT("ProgramListText"),					TEXT("番組表パネル番組内容文字")},
< 	{HEXRGB(0x777777),	TEXT("ProgramListBorder"),					TEXT("番組表パネル番組内容外枠")},
< 	{HEXRGB(0x777777),	TEXT("ProgramListCurBack"),					TEXT("番組表パネル現在番組内容背景1")},
< 	{HEXRGB(0x888888),	TEXT("ProgramListCurBack2"),				TEXT("番組表パネル現在番組内容背景2")},
< 	{HEXRGB(0xDDDDDD),	TEXT("ProgramListCurText"),					TEXT("番組表パネル現在番組内容文字")},
< 	{HEXRGB(0x777777),	TEXT("ProgramListCurBorder"),				TEXT("番組表パネル現在番組内容外枠")},
< 	{HEXRGB(0x777777),	TEXT("ProgramListTitleBack"),				TEXT("番組表パネル番組名背景1")},
< 	{HEXRGB(0x555555),	TEXT("ProgramListTitleBack2"),				TEXT("番組表パネル番組名背景2")},
< 	{HEXRGB(0xCCCCCC),	TEXT("ProgramListTitleText"),				TEXT("番組表パネル番組名文字")},
< 	{HEXRGB(0x777777),	TEXT("ProgramListTitleBorder"),				TEXT("番組表パネル番組名外枠")},
< 	{HEXRGB(0x3384FF),	TEXT("ProgramListCurTitleBack"),			TEXT("番組表パネル現在番組名背景1")},
< 	{HEXRGB(0x33D6FF),	TEXT("ProgramListCurTitleBack2"),			TEXT("番組表パネル現在番組名背景2")},
< 	{HEXRGB(0x333333),	TEXT("ProgramListCurTitleText"),			TEXT("番組表パネル現在番組名文字")},
< 	{HEXRGB(0x3384FF),	TEXT("ProgramListCurTitleBorder"),			TEXT("番組表パネル現在番組名外枠")},
< 	{HEXRGB(0x777777),	TEXT("ChannelPanelChannelNameBack"),		TEXT("チャンネルパネル局名背景1")},
< 	{HEXRGB(0x555555),	TEXT("ChannelPanelChannelNameBack2"),		TEXT("チャンネルパネル局名背景2")},
< 	{HEXRGB(0xCCCCCC),	TEXT("ChannelPanelChannelNameText"),		TEXT("チャンネルパネル局名文字")},
< 	{HEXRGB(0x555555),	TEXT("ChannelPanelChannelNameBorder"),		TEXT("チャンネルパネル局名外枠")},
< 	{HEXRGB(0x3384FF),	TEXT("ChannelPanelCurChannelNameBack"),		TEXT("チャンネルパネル現在局名背景1")},
< 	{HEXRGB(0x33D6FF),	TEXT("ChannelPanelCurChannelNameBack2"),	TEXT("チャンネルパネル現在局名背景2")},
< 	{HEXRGB(0x333333),	TEXT("ChannelPanelCurChannelNameText"),		TEXT("チャンネルパネル現在局名文字")},
< 	{HEXRGB(0x3384FF),	TEXT("ChannelPanelCurChannelNameBorder"),	TEXT("チャンネルパネル現在局名外枠")},
< 	{HEXRGB(0x777777),	TEXT("ChannelPanelEventNameBack"),			TEXT("チャンネルパネル番組名1背景1")},
< 	{HEXRGB(0x888888),	TEXT("ChannelPanelEventNameBack2"),			TEXT("チャンネルパネル番組名1背景2")},
< 	{HEXRGB(0xDDDDDD),	TEXT("ChannelPanelEventNameText"),			TEXT("チャンネルパネル番組名1文字")},
< 	{HEXRGB(0x888888),	TEXT("ChannelPanelEventNameBorder"),		TEXT("チャンネルパネル番組名1外枠")},
< 	{HEXRGB(0x777777),	TEXT("ChannelPanelEventName2Back"),			TEXT("チャンネルパネル番組名2背景1")},
< 	{HEXRGB(0x888888),	TEXT("ChannelPanelEventName2Back2"),		TEXT("チャンネルパネル番組名2背景2")},
< 	{HEXRGB(0xDDDDDD),	TEXT("ChannelPanelEventName2Text"),			TEXT("チャンネルパネル番組名2文字")},
< 	{HEXRGB(0x888888),	TEXT("ChannelPanelEventName2Border"),		TEXT("チャンネルパネル番組名2外枠")},
< 	{HEXRGB(0x777777),	TEXT("ChannelPanelCurEventNameBack"),		TEXT("チャンネルパネル選択番組名1背景1")},
< 	{HEXRGB(0x888888),	TEXT("ChannelPanelCurEventNameBack2"),		TEXT("チャンネルパネル選択番組名1背景2")},
< 	{HEXRGB(0xDDDDDD),	TEXT("ChannelPanelCurEventNameText"),		TEXT("チャンネルパネル選択番組名1文字")},
< 	{HEXRGB(0x888888),	TEXT("ChannelPanelCurEventNameBorder"),		TEXT("チャンネルパネル選択番組名1外枠")},
< 	{HEXRGB(0x777777),	TEXT("ChannelPanelCurEventName2Back"),		TEXT("チャンネルパネル選択番組名2背景1")},
< 	{HEXRGB(0x888888),	TEXT("ChannelPanelCurEventName2Back2"),		TEXT("チャンネルパネル選択番組名2背景2")},
< 	{HEXRGB(0xDDDDDD),	TEXT("ChannelPanelCurEventName2Text"),		TEXT("チャンネルパネル選択番組名2文字")},
< 	{HEXRGB(0x888888),	TEXT("ChannelPanelCurEventName2Border"),	TEXT("チャンネルパネル選択番組名2外枠")},
< 	{HEXRGB(0x666666),	TEXT("ControlPanelBack"),					TEXT("操作パネル背景1")},
< 	{HEXRGB(0x666666),	TEXT("ControlPanelBack2"),					TEXT("操作パネル背景2")},
< 	{HEXRGB(0xCCCCCC),	TEXT("ControlPanelText"),					TEXT("操作パネル文字")},
< 	{HEXRGB(0x666666),	TEXT("ControlPanelItemBorder"),				TEXT("操作パネル項目外枠")},
< 	{HEXRGB(0x3384FF),	TEXT("ControlPanelHighlightBack"),			TEXT("操作パネル選択背景1")},
< 	{HEXRGB(0x33D6FF),	TEXT("ControlPanelHighlightBack2"),			TEXT("操作パネル選択背景2")},
< 	{HEXRGB(0xEEEEEE),	TEXT("ControlPanelHighlightText"),			TEXT("操作パネル選択文字")},
< 	{HEXRGB(0x3384FF),	TEXT("ControlPanelHighlightBorder"),		TEXT("操作パネル選択項目外枠")},
< 	{HEXRGB(0x666666),	TEXT("ControlPanelMargin"),					TEXT("操作パネル余白")},
< 	{HEXRGB(0x777777),	TEXT("CaptionPanelBack"),					TEXT("字幕パネル背景")},
< 	{HEXRGB(0xDDDDDD),	TEXT("CaptionPanelText"),					TEXT("字幕パネル文字")},
< 	{HEXRGB(0x777777),	TEXT("TitleBarBack"),						TEXT("タイトルバー背景1")},
< 	{HEXRGB(0x222222),	TEXT("TitleBarBack2"),						TEXT("タイトルバー背景2")},
< 	{HEXRGB(0xBBBBBB),	TEXT("TitleBarText"),						TEXT("タイトルバー文字")},
< 	{HEXRGB(0x777777),	TEXT("TitleBarTextBorder"),					TEXT("タイトルバー文字外枠")},
< 	{HEXRGB(0x777777),	TEXT("TitleBarIconBack"),					TEXT("タイトルバーアイコン背景1")},
< 	{HEXRGB(0x222222),	TEXT("TitleBarIconBack2"),					TEXT("タイトルバーアイコン背景2")},
< 	{HEXRGB(0xBBBBBB),	TEXT("TitleBarIcon"),						TEXT("タイトルバーアイコン")},
< 	{HEXRGB(0x777777),	TEXT("TitleBarIconBorder"),					TEXT("タイトルバーアイコン外枠")},
< 	{HEXRGB(0x3384FF),	TEXT("TitleBarHighlightBack"),				TEXT("タイトルバー選択背景1")},
< 	{HEXRGB(0x33D6FF),	TEXT("TitleBarHighlightBack2"),				TEXT("タイトルバー選択背景2")},
< 	{HEXRGB(0x444444),	TEXT("TitleBarHighlightIcon"),				TEXT("タイトルバー選択アイコン")},
< 	{HEXRGB(0x3384FF),	TEXT("TitleBarHighlightIconBorder"),		TEXT("タイトルバー選択アイコン外枠")},
< 	{HEXRGB(0x777777),	TEXT("TitleBarBorder"),						TEXT("タイトルバー外枠")},
< 	{HEXRGB(0x777777),	TEXT("SideBarBack"),						TEXT("サイドバー背景1")},
< 	{HEXRGB(0x222222),	TEXT("SideBarBack2"),						TEXT("サイドバー背景2")},
< 	{HEXRGB(0xBBBBBB),	TEXT("SideBarIcon"),						TEXT("サイドバーアイコン")},
< 	{HEXRGB(0x777777),	TEXT("SideBarItemBorder"),					TEXT("サイドバー項目外枠")},
< 	{HEXRGB(0x3384FF),	TEXT("SideBarHighlightBack"),				TEXT("サイドバー選択背景1")},
< 	{HEXRGB(0x33D6FF),	TEXT("SideBarHighlightBack2"),				TEXT("サイドバー選択背景2")},
< 	{HEXRGB(0x444444),	TEXT("SideBarHighlightIcon"),				TEXT("サイドバー選択アイコン")},
< 	{HEXRGB(0x3384FF),	TEXT("SideBarHighlightBorder"),				TEXT("サイドバー選択外枠")},
< 	{HEXRGB(0x777777),	TEXT("SideBarCheckBack"),					TEXT("サイドバーチェック背景1")},
< 	{HEXRGB(0x222222),	TEXT("SideBarCheckBack2"),					TEXT("サイドバーチェック背景2")},
< 	{HEXRGB(0xBBBBBB),	TEXT("SideBarCheckIcon"),					TEXT("サイドバーチェックアイコン")},
< 	{HEXRGB(0x444444),	TEXT("SideBarCheckBorder"),					TEXT("サイドバーチェック外枠")},
< 	{HEXRGB(0x777777),	TEXT("SideBarBorder"),						TEXT("サイドバー外枠")},
< 	{HEXRGB(0x222222),	TEXT("NotificationBarBack"),				TEXT("通知バー背景1")},
< 	{HEXRGB(0x333333),	TEXT("NotificationBarBack2"),				TEXT("通知バー背景2")},
< 	{HEXRGB(0xBBBBBB),	TEXT("NotificationBarText"),				TEXT("通知バー文字")},
< 	{HEXRGB(0xFF9F44),	TEXT("NotificationBarWarningText"),			TEXT("通知バー警告文字")},
< 	{HEXRGB(0xFF4444),	TEXT("NotificationBarErrorText"),			TEXT("通知バーエラー文字")},
< 	{HEXRGB(0x666666),	TEXT("ProgramGuideBack"),					TEXT("EPG番組表背景")},
< 	{HEXRGB(0x000000),	TEXT("ProgramGuideText"),					TEXT("EPG番組表文字")},
< 	{HEXRGB(0x777777),	TEXT("ProgramGuideChannelBack"),			TEXT("EPG番組表チャンネル名背景1")},
< 	{HEXRGB(0x222222),	TEXT("ProgramGuideChannelBack2"),			TEXT("EPG番組表チャンネル名背景2")},
< 	{HEXRGB(0xBBBBBB),	TEXT("ProgramGuideChannelText"),			TEXT("EPG番組表チャンネル名文字")},
< 	{HEXRGB(0x3384FF),	TEXT("ProgramGuideCurChannelBack"),			TEXT("EPG番組表チャンネル名選択背景1")},
< 	{HEXRGB(0x33D6FF),	TEXT("ProgramGuideCurChannelBack2"),		TEXT("EPG番組表チャンネル名選択背景2")},
< 	{HEXRGB(0x333333),	TEXT("ProgramGuideCurChannelText"),			TEXT("EPG番組表チャンネル名選択文字")},
< 	{HEXRGB(0x888888),	TEXT("ProgramGuideTimeBack"),				TEXT("EPG番組表日時背景1")},
< 	{HEXRGB(0x777777),	TEXT("ProgramGuideTimeBack2"),				TEXT("EPG番組表日時背景2")},
< 	{HEXRGB(0x004CBF),	TEXT("ProgramGuideTime0To2Back"),			TEXT("EPG番組表0～2時背景1")},
< 	{HEXRGB(0x00337F),	TEXT("ProgramGuideTime0To2Back2"),			TEXT("EPG番組表0～2時背景2")},
< 	{HEXRGB(0x0099BF),	TEXT("ProgramGuideTime3To5Back"),			TEXT("EPG番組表3～5時背景1")},
< 	{HEXRGB(0x00667F),	TEXT("ProgramGuideTime3To5Back2"),			TEXT("EPG番組表3～5時背景2")},
< 	{HEXRGB(0x00BF99),	TEXT("ProgramGuideTime6To8Back"),			TEXT("EPG番組表6～8時背景1")},
< 	{HEXRGB(0x007F66),	TEXT("ProgramGuideTime6To8Back2"),			TEXT("EPG番組表6～8時背景2")},
< 	{HEXRGB(0x99BF00),	TEXT("ProgramGuideTime9To11Back"),			TEXT("EPG番組表9～11時背景1")},
< 	{HEXRGB(0x667F00),	TEXT("ProgramGuideTime9To11Back2"),			TEXT("EPG番組表9～11時背景2")},
< 	{HEXRGB(0xBF9900),	TEXT("ProgramGuideTime12To14Back"),			TEXT("EPG番組表12～14時背景1")},
< 	{HEXRGB(0x7F6600),	TEXT("ProgramGuideTime12To14Back2"),		TEXT("EPG番組表12～14時背景2")},
< 	{HEXRGB(0xBF4C00),	TEXT("ProgramGuideTime15To17Back"),			TEXT("EPG番組表15～17時背景1")},
< 	{HEXRGB(0x7F3300),	TEXT("ProgramGuideTime15To17Back2"),		TEXT("EPG番組表15～17間背景2")},
< 	{HEXRGB(0xBF0099),	TEXT("ProgramGuideTime18To20Back"),			TEXT("EPG番組表18～20時背景1")},
< 	{HEXRGB(0x7F0066),	TEXT("ProgramGuideTime18To20Back2"),		TEXT("EPG番組表18～20時背景2")},
< 	{HEXRGB(0x9900BF),	TEXT("ProgramGuideTime21To23Back"),			TEXT("EPG番組表21～23時背景1")},
< 	{HEXRGB(0x66007F),	TEXT("ProgramGuideTime21To23Back2"),		TEXT("EPG番組表21～23時背景2")},
< 	{HEXRGB(0xDDDDDD),	TEXT("ProgramGuideTimeText"),				TEXT("EPG番組表時間文字")},
< 	{HEXRGB(0xBBBBBB),	TEXT("ProgramGuideTimeLine"),				TEXT("EPG番組表時間線")},
< 	{HEXRGB(0xFF6600),	TEXT("ProgramGuideCurTimeLine"),			TEXT("EPG番組表現在時刻線")},
< 	{RGB(255,255,224),	TEXT("EPGContentNews"),						TEXT("EPG番組表ニュース番組")},
< 	{RGB(224,224,255),	TEXT("EPGContentSports"),					TEXT("EPG番組表スポーツ番組")},
< 	{RGB(255,224,240),	TEXT("EPGContentInformation"),				TEXT("EPG番組表情報番組")},
< 	{RGB(255,224,224),	TEXT("EPGContentDrama"),					TEXT("EPG番組表ドラマ")},
< 	{RGB(224,255,224),	TEXT("EPGContentMusic"),					TEXT("EPG番組表音楽番組")},
< 	{RGB(224,255,255),	TEXT("EPGContentVariety"),					TEXT("EPG番組表バラエティ番組")},
< 	{RGB(255,240,224),	TEXT("EPGContentMovie"),					TEXT("EPG番組表映画")},
< 	{RGB(255,224,255),	TEXT("EPGContentAnime"),					TEXT("EPG番組表アニメ/特撮")},
< 	{RGB(255,255,224),	TEXT("EPGContentDocumentary"),				TEXT("EPG番組表ドキュメンタリー/教養番組")},
< 	{RGB(255,240,224),	TEXT("EPGContentTheater"),					TEXT("EPG番組表劇場/公演")},
< 	{RGB(224,240,255),	TEXT("EPGContentEducation"),				TEXT("EPG番組表趣味/教育番組")},
< 	{RGB(224,240,255),	TEXT("EPGContentWelfare"),					TEXT("EPG番組表福祉番組")},
< 	{RGB(240,240,240),	TEXT("EPGContentOther"),					TEXT("EPG番組表その他の番組")},
200,267d51
< 	{TEXT("PanelTabBackGradient"),						Theme::DIRECTION_VERT,	true,
< 		COLOR_PANELTABBACK1,					COLOR_PANELTABBACK2},
< 	{TEXT("PanelCurTabBackGradient"),					Theme::DIRECTION_VERT,	true,
< 		COLOR_PANELCURTABBACK1,					COLOR_PANELCURTABBACK2},
< 	{TEXT("PanelTabMarginGradient"),					Theme::DIRECTION_VERT,	false,
< 		COLOR_PANELTABMARGIN1,					COLOR_PANELTABMARGIN2},
< 	{TEXT("PanelTitleBackGradient"),					Theme::DIRECTION_VERT,	true,
< 		COLOR_PANELTITLEBACK1,					COLOR_PANELTITLEBACK2},
< 	{TEXT("ProgramListBackGradient"),					Theme::DIRECTION_VERT,	true,
< 		COLOR_PROGRAMLISTPANEL_EVENTBACK1,		COLOR_PROGRAMLISTPANEL_EVENTBACK2},
< 	{TEXT("ProgramListCurBackGradient"),				Theme::DIRECTION_VERT,	true,
< 		COLOR_PROGRAMLISTPANEL_CUREVENTBACK1,	COLOR_PROGRAMLISTPANEL_CUREVENTBACK2},
< 	{TEXT("ProgramListTitleBackGradient"),				Theme::DIRECTION_VERT,	true,
< 		COLOR_PROGRAMLISTPANEL_TITLEBACK1,		COLOR_PROGRAMLISTPANEL_TITLEBACK2},
< 	{TEXT("ProgramListCurTitleBackGradient"),			Theme::DIRECTION_VERT,	true,
< 		COLOR_PROGRAMLISTPANEL_CURTITLEBACK1,	COLOR_PROGRAMLISTPANEL_CURTITLEBACK2},
< 	{TEXT("ChannelPanelChannelNameBackGradient"),		Theme::DIRECTION_VERT,	true,
< 		COLOR_CHANNELPANEL_CHANNELNAMEBACK1,	COLOR_CHANNELPANEL_CHANNELNAMEBACK2},
< 	{TEXT("ChannelPanelCurChannelNameBackGradient"),	Theme::DIRECTION_VERT,	true,
< 		COLOR_CHANNELPANEL_CURCHANNELNAMEBACK1,	COLOR_CHANNELPANEL_CURCHANNELNAMEBACK2},
< 	{TEXT("ChannelPanelEventNameBackGradient"),			Theme::DIRECTION_VERT,	true,
< 		COLOR_CHANNELPANEL_EVENTNAME1BACK1,		COLOR_CHANNELPANEL_EVENTNAME1BACK2},
< 	{TEXT("ChannelPanelEventName2BackGradient"),		Theme::DIRECTION_VERT,	true,
< 		COLOR_CHANNELPANEL_EVENTNAME2BACK1,		COLOR_CHANNELPANEL_EVENTNAME2BACK2},
< 	{TEXT("ChannelPanelCurEventNameBackGradient"),		Theme::DIRECTION_VERT,	true,
< 		COLOR_CHANNELPANEL_CUREVENTNAME1BACK1,	COLOR_CHANNELPANEL_CUREVENTNAME1BACK2},
< 	{TEXT("ChannelPanelCurEventName2BackGradient"),		Theme::DIRECTION_VERT,	true,
< 		COLOR_CHANNELPANEL_CUREVENTNAME2BACK1,	COLOR_CHANNELPANEL_CUREVENTNAME2BACK2},
< 	{TEXT("ControlPanelBackGradient"),					Theme::DIRECTION_VERT,	true,
< 		COLOR_CONTROLPANELBACK1,				COLOR_CONTROLPANELBACK2},
< 	{TEXT("ControlPanelHighlightBackGradient"),			Theme::DIRECTION_VERT,	true,
< 		COLOR_CONTROLPANELHIGHLIGHTBACK1,		COLOR_CONTROLPANELHIGHLIGHTBACK2},
< 	{TEXT("TitleBarBackGradient"),						Theme::DIRECTION_VERT,	true,
< 		COLOR_TITLEBARBACK1,					COLOR_TITLEBARBACK2},
< 	{TEXT("TitleBarIconBackGradient"),					Theme::DIRECTION_VERT,	true,
< 		COLOR_TITLEBARICONBACK1,				COLOR_TITLEBARICONBACK2},
< 	{TEXT("TitleBarHighlightBackGradient"),				Theme::DIRECTION_VERT,	true,
< 		COLOR_TITLEBARHIGHLIGHTBACK1,			COLOR_TITLEBARHIGHLIGHTBACK2},
< 	{TEXT("SideBarBackGradient"),						Theme::DIRECTION_HORZ,	true,
< 		COLOR_SIDEBARBACK1,						COLOR_SIDEBARBACK2},
< 	{TEXT("SideBarHighlightBackGradient"),				Theme::DIRECTION_HORZ,	true,
< 		COLOR_SIDEBARHIGHLIGHTBACK1,			COLOR_SIDEBARHIGHLIGHTBACK2},
< 	{TEXT("SideBarCheckBackGradient"),					Theme::DIRECTION_HORZ,	true,
< 		COLOR_SIDEBARCHECKBACK1,				COLOR_SIDEBARCHECKBACK2},
< 	{TEXT("NotificationBarBackGradient"),				Theme::DIRECTION_VERT,	true,
< 		COLOR_NOTIFICATIONBARBACK1,				COLOR_NOTIFICATIONBARBACK2},
< 	{TEXT("ProgramGuideChannelBackGradient"),			Theme::DIRECTION_VERT,	true,
< 		COLOR_PROGRAMGUIDECHANNELBACK1,			COLOR_PROGRAMGUIDECHANNELBACK2},
< 	{TEXT("ProgramGuideCurChannelBackGradient"),		Theme::DIRECTION_VERT,	true,
< 		COLOR_PROGRAMGUIDECURCHANNELBACK1,		COLOR_PROGRAMGUIDECURCHANNELBACK2},
< 	{TEXT("ProgramGuideTimeBackGradient"),				Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK1,			COLOR_PROGRAMGUIDETIMEBACK2},
< 	{TEXT("ProgramGuideTime0To2BackGradient"),			Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK_0TO2_1,		COLOR_PROGRAMGUIDETIMEBACK_0TO2_2},
< 	{TEXT("ProgramGuideTime3To5BackGradient"),			Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK_3TO5_1,		COLOR_PROGRAMGUIDETIMEBACK_3TO5_2},
< 	{TEXT("ProgramGuideTime6To8BackGradient"),			Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK_6TO8_1,		COLOR_PROGRAMGUIDETIMEBACK_6TO8_2},
< 	{TEXT("ProgramGuideTime9To11BackGradient"),			Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK_9TO11_1,		COLOR_PROGRAMGUIDETIMEBACK_9TO11_2},
< 	{TEXT("ProgramGuideTime12To14BackGradient"),		Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK_12TO14_1,	COLOR_PROGRAMGUIDETIMEBACK_12TO14_2},
< 	{TEXT("ProgramGuideTime15To17BackGradient"),		Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK_15TO17_1,	COLOR_PROGRAMGUIDETIMEBACK_15TO17_2},
< 	{TEXT("ProgramGuideTime18To20BackGradient"),		Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK_18TO20_1,	COLOR_PROGRAMGUIDETIMEBACK_18TO20_2},
< 	{TEXT("ProgramGuideTime21To23BackGradient"),		Theme::DIRECTION_HORZ,	true,
< 		COLOR_PROGRAMGUIDETIMEBACK_21TO23_1,	COLOR_PROGRAMGUIDETIMEBACK_21TO23_2},
281,330d64
< 	{TEXT("TitleBarBorder"),					Theme::BORDER_RAISED,
< 		COLOR_TITLEBARBORDER,						true},
< 	{TEXT("TitleBarCaptionBorder"),				Theme::BORDER_NONE,
< 		COLOR_TITLEBARTEXTBORDER,					false},
< 	{TEXT("TitleBarIconBorder"),				Theme::BORDER_NONE,
< 		COLOR_TITLEBARICONBORDER,					false},
< 	{TEXT("TitleBarHighlightBorder"),			Theme::BORDER_NONE,
< 		COLOR_TITLEBARHIGHLIGHTBORDER,				false},
< 	{TEXT("SideBarBorder"),						Theme::BORDER_RAISED,
< 		COLOR_SIDEBARBORDER,						true},
< 	{TEXT("SideBarItemBorder"),					Theme::BORDER_NONE,
< 		COLOR_SIDEBARITEMBORDER,					false},
< 	{TEXT("SideBarHighlightBorder"),			Theme::BORDER_NONE,
< 		COLOR_SIDEBARHIGHLIGHTBORDER,				false},
< 	{TEXT("SideBarCheckBorder"),				Theme::BORDER_SUNKEN,
< 		COLOR_SIDEBARCHECKBORDER,					false},
< 	{TEXT("ProgramGuideStatusBorder"),			Theme::BORDER_SUNKEN,
< 		COLOR_STATUSBORDER,							true},
< 	{TEXT("PanelTabBorder"),					Theme::BORDER_SOLID,
< 		COLOR_PANELTABBORDER,						false},
< 	{TEXT("PanelCurTabBorder"),					Theme::BORDER_SOLID,
< 		COLOR_PANELCURTABBORDER,					false},
< 	{TEXT("PanelTabMarginBorder"),				Theme::BORDER_NONE,
< 		COLOR_PANELTABMARGINBORDER,					false},
< 	{TEXT("PanelTitleBorder"),					Theme::BORDER_RAISED,
< 		COLOR_PANELTITLEBORDER,						false},
< 	{TEXT("ProgramListPanelEventBorder"),		Theme::BORDER_NONE,
< 		COLOR_PROGRAMLISTPANEL_EVENTBORDER,			false},
< 	{TEXT("ProgramListPanelCurEventBorder"),	Theme::BORDER_NONE,
< 		COLOR_PROGRAMLISTPANEL_CUREVENTBORDER,		false},
< 	{TEXT("ProgramListPanelTitleBorder"),		Theme::BORDER_NONE,
< 		COLOR_PROGRAMLISTPANEL_TITLEBORDER,			false},
< 	{TEXT("ProgramListPanelCurTitleBorder"),	Theme::BORDER_NONE,
< 		COLOR_PROGRAMLISTPANEL_CURTITLEBORDER,		false},
< 	{TEXT("ChannelPanelChannelNameBorder"),		Theme::BORDER_NONE,
< 		COLOR_CHANNELPANEL_CHANNELNAMEBORDER,		false},
< 	{TEXT("ChannelPanelCurChannelNameBorder"),	Theme::BORDER_NONE,
< 		COLOR_CHANNELPANEL_CURCHANNELNAMEBORDER,	false},
< 	{TEXT("ChannelPanelEventNameBorder"),		Theme::BORDER_NONE,
< 		COLOR_CHANNELPANEL_EVENTNAME1BORDER,		false},
< 	{TEXT("ChannelPanelEventName2Border"),		Theme::BORDER_NONE,
< 		COLOR_CHANNELPANEL_EVENTNAME2BORDER,		false},
< 	{TEXT("ChannelPanelCurEventNameBorder"),	Theme::BORDER_NONE,
< 		COLOR_CHANNELPANEL_CUREVENTNAME1BORDER,		false},
< 	{TEXT("ChannelPanelCurEventName2Border"),	Theme::BORDER_NONE,
< 		COLOR_CHANNELPANEL_CUREVENTNAME2BORDER,		false},
< 	{TEXT("ControlPanelItemBorder"),			Theme::BORDER_NONE,
< 		COLOR_CONTROLPANELITEMBORDER,				false},
< 	{TEXT("ControlPanelHighlightBorder"),		Theme::BORDER_NONE,
< 		COLOR_CONTROLPANELHIGHLIGHTBORDER,			false},
340,383d73
< 	{GRADIENT_TITLEBARBACK,						BORDER_TITLEBARCAPTION,
< 		COLOR_TITLEBARTEXT},
< 	{GRADIENT_TITLEBARICON,						BORDER_TITLEBARICON,
< 		COLOR_TITLEBARICON},
< 	{GRADIENT_TITLEBARHIGHLIGHTBACK,			BORDER_TITLEBARHIGHLIGHT,
< 		COLOR_TITLEBARHIGHLIGHTICON},
< 	{GRADIENT_SIDEBARBACK,						BORDER_SIDEBARITEM,
< 		COLOR_SIDEBARICON},
< 	{GRADIENT_SIDEBARHIGHLIGHTBACK,				BORDER_SIDEBARHIGHLIGHT,
< 		COLOR_SIDEBARHIGHLIGHTICON},
< 	{GRADIENT_SIDEBARCHECKBACK,					BORDER_SIDEBARCHECK,
< 		COLOR_SIDEBARCHECKICON},
< 	{GRADIENT_PANELTABBACK,						BORDER_PANEL_TAB,
< 		COLOR_PANELTABTEXT},
< 	{GRADIENT_PANELCURTABBACK,					BORDER_PANEL_CURTAB,
< 		COLOR_PANELCURTABTEXT},
< 	{GRADIENT_PANELTABMARGIN,					BORDER_PANEL_TABMARGIN,
< 		-1},
< 	{GRADIENT_PANELTITLEBACK,					BORDER_PANEL_TITLE,
< 		COLOR_PANELTITLETEXT},
< 	{GRADIENT_PROGRAMLISTPANEL_EVENTBACK,		BORDER_PROGRAMLISTPANEL_EVENT,
< 		COLOR_PROGRAMLISTPANEL_EVENTTEXT},
< 	{GRADIENT_PROGRAMLISTPANEL_CUREVENTBACK,	BORDER_PROGRAMLISTPANEL_CUREVENT,
< 		COLOR_PROGRAMLISTPANEL_CUREVENTTEXT},
< 	{GRADIENT_PROGRAMLISTPANEL_TITLEBACK,		BORDER_PROGRAMLISTPANEL_TITLE,
< 		COLOR_PROGRAMLISTPANEL_TITLETEXT},
< 	{GRADIENT_PROGRAMLISTPANEL_CURTITLEBACK,	BORDER_PROGRAMLISTPANEL_CURTITLE,
< 		COLOR_PROGRAMLISTPANEL_CURTITLETEXT},
< 	{GRADIENT_CHANNELPANEL_CHANNELNAMEBACK,		BORDER_CHANNELPANEL_CHANNELNAME,
< 		COLOR_CHANNELPANEL_CHANNELNAMETEXT},
< 	{GRADIENT_CHANNELPANEL_CURCHANNELNAMEBACK,	BORDER_CHANNELPANEL_CURCHANNELNAME,
< 		COLOR_CHANNELPANEL_CURCHANNELNAMETEXT},
< 	{GRADIENT_CHANNELPANEL_EVENTNAMEBACK1,		BORDER_CHANNELPANEL_EVENTNAME1,
< 		COLOR_CHANNELPANEL_EVENTNAME1TEXT},
< 	{GRADIENT_CHANNELPANEL_EVENTNAMEBACK2,		BORDER_CHANNELPANEL_EVENTNAME2,
< 		COLOR_CHANNELPANEL_EVENTNAME2TEXT},
< 	{GRADIENT_CHANNELPANEL_CUREVENTNAMEBACK1,	BORDER_CHANNELPANEL_CUREVENTNAME1,
< 		COLOR_CHANNELPANEL_CUREVENTNAME1TEXT},
< 	{GRADIENT_CHANNELPANEL_CUREVENTNAMEBACK2,	BORDER_CHANNELPANEL_CUREVENTNAME2,
< 		COLOR_CHANNELPANEL_CUREVENTNAME2TEXT},
< 	{GRADIENT_CONTROLPANELBACK,					BORDER_CONTROLPANELITEM,
< 		COLOR_CONTROLPANELTEXT},
< 	{GRADIENT_CONTROLPANELHIGHLIGHTBACK,		BORDER_CONTROLPANELHIGHLIGHTITEM,
< 		COLOR_CONTROLPANELHIGHLIGHTTEXT},
542c232,236
< 	return m_Name.Set(pszName);
---
> 	if (pszName) {
> 		m_Name=pszName;
> 		return true;
> 	}
> 	return false;
546c240
< bool CColorScheme::Load(CSettings &Settings)
---
> bool CColorScheme::Load(LPCTSTR pszFileName)
547a242
> 	CSettings Settings;
551c246
< 	if (!Settings.SetSection(TEXT("ColorScheme")))
---
> 	if (!Settings.Open(pszFileName,TEXT("ColorScheme"),CSettings::OPEN_READ))
574,576d268
< 		} else if (i==COLOR_SPLITTER) {
< 			m_ColorList[i]=::GetSysColor(COLOR_3DFACE);
< 			SetLoadedFlag(i);
586,639d277
< 				{COLOR_PROGRAMLISTPANEL_CUREVENTBACK1,		COLOR_PROGRAMLISTPANEL_EVENTBACK1},
< 				{COLOR_PROGRAMLISTPANEL_CUREVENTBACK2,		COLOR_PROGRAMLISTPANEL_EVENTBACK2},
< 				{COLOR_PROGRAMLISTPANEL_CUREVENTTEXT,		COLOR_PROGRAMLISTPANEL_EVENTTEXT},
< 				{COLOR_PROGRAMLISTPANEL_CURTITLEBACK1,		COLOR_PROGRAMLISTPANEL_TITLEBACK1},
< 				{COLOR_PROGRAMLISTPANEL_CURTITLEBACK2,		COLOR_PROGRAMLISTPANEL_TITLEBACK2},
< 				{COLOR_PROGRAMLISTPANEL_CURTITLETEXT,		COLOR_PROGRAMLISTPANEL_TITLETEXT},
< 				{COLOR_PANELTABLINE,						COLOR_PANELTABBORDER},
< 			//	{COLOR_PANELTITLEBORDER,					COLOR_PANELTITLEBACK1},
< 				{COLOR_CHANNELPANEL_CURCHANNELNAMEBACK1,	COLOR_CHANNELPANEL_CHANNELNAMEBACK1},
< 				{COLOR_CHANNELPANEL_CURCHANNELNAMEBACK2,	COLOR_CHANNELPANEL_CHANNELNAMEBACK2},
< 				{COLOR_CHANNELPANEL_CURCHANNELNAMETEXT,		COLOR_CHANNELPANEL_CHANNELNAMETEXT},
< 				{COLOR_CHANNELPANEL_EVENTNAME2BACK1,		COLOR_CHANNELPANEL_EVENTNAME1BACK1},
< 				{COLOR_CHANNELPANEL_EVENTNAME2BACK2,		COLOR_CHANNELPANEL_EVENTNAME1BACK2},
< 				{COLOR_CHANNELPANEL_EVENTNAME2TEXT,			COLOR_CHANNELPANEL_EVENTNAME1TEXT},
< 				{COLOR_CHANNELPANEL_EVENTNAME2BORDER,		COLOR_CHANNELPANEL_EVENTNAME1BORDER},
< 				{COLOR_CHANNELPANEL_CUREVENTNAME1BACK1,		COLOR_CHANNELPANEL_EVENTNAME1BACK1},
< 				{COLOR_CHANNELPANEL_CUREVENTNAME1BACK2,		COLOR_CHANNELPANEL_EVENTNAME1BACK2},
< 				{COLOR_CHANNELPANEL_CUREVENTNAME1TEXT,		COLOR_CHANNELPANEL_EVENTNAME1TEXT},
< 				{COLOR_CHANNELPANEL_CUREVENTNAME1BORDER,	COLOR_CHANNELPANEL_EVENTNAME1BORDER},
< 				{COLOR_CHANNELPANEL_CUREVENTNAME2BACK1,		COLOR_CHANNELPANEL_CUREVENTNAME1BACK1},
< 				{COLOR_CHANNELPANEL_CUREVENTNAME2BACK2,		COLOR_CHANNELPANEL_CUREVENTNAME1BACK2},
< 				{COLOR_CHANNELPANEL_CUREVENTNAME2TEXT,		COLOR_CHANNELPANEL_CUREVENTNAME1TEXT},
< 				{COLOR_CHANNELPANEL_CUREVENTNAME2BORDER,	COLOR_CHANNELPANEL_CUREVENTNAME1BORDER},
< 				{COLOR_CONTROLPANELBACK1,					COLOR_PANELBACK},
< 				{COLOR_CONTROLPANELBACK2,					COLOR_PANELBACK},
< 				{COLOR_CONTROLPANELTEXT,					COLOR_PANELTEXT},
< 				{COLOR_CONTROLPANELMARGIN,					COLOR_PANELBACK},
< 				{COLOR_CAPTIONPANELBACK,					COLOR_PROGRAMINFOBACK},
< 				{COLOR_CAPTIONPANELTEXT,					COLOR_PROGRAMINFOTEXT},
< 				{COLOR_TITLEBARBACK1,						COLOR_STATUSBACK1},
< 				{COLOR_TITLEBARBACK2,						COLOR_STATUSBACK2},
< 				{COLOR_TITLEBARTEXT,						COLOR_STATUSTEXT},
< 				{COLOR_TITLEBARICONBACK1,					COLOR_TITLEBARBACK1},
< 				{COLOR_TITLEBARICONBACK2,					COLOR_TITLEBARBACK2},
< 				{COLOR_TITLEBARICON,						COLOR_TITLEBARTEXT},
< 				{COLOR_TITLEBARHIGHLIGHTBACK1,				COLOR_STATUSHIGHLIGHTBACK1},
< 				{COLOR_TITLEBARHIGHLIGHTBACK2,				COLOR_STATUSHIGHLIGHTBACK2},
< 				{COLOR_TITLEBARHIGHLIGHTICON,				COLOR_STATUSHIGHLIGHTTEXT},
< 			//	{COLOR_TITLEBARBORDER,						COLOR_TITLEBARBACK1},
< 				{COLOR_SIDEBARBACK1,						COLOR_STATUSBACK1},
< 				{COLOR_SIDEBARBACK2,						COLOR_STATUSBACK2},
< 				{COLOR_SIDEBARICON,							COLOR_STATUSTEXT},
< 				{COLOR_SIDEBARHIGHLIGHTBACK1,				COLOR_STATUSHIGHLIGHTBACK1},
< 				{COLOR_SIDEBARHIGHLIGHTBACK2,				COLOR_STATUSHIGHLIGHTBACK2},
< 				{COLOR_SIDEBARHIGHLIGHTICON,				COLOR_STATUSHIGHLIGHTTEXT},
< 				{COLOR_SIDEBARCHECKBACK1,					COLOR_SIDEBARBACK1},
< 				{COLOR_SIDEBARCHECKBACK2,					COLOR_SIDEBARBACK2},
< 				{COLOR_SIDEBARCHECKICON,					COLOR_SIDEBARICON},
< 			//	{COLOR_SIDEBARCHECKBORDER,					COLOR_SIDEBARCHECKBACK2},
< 			//	{COLOR_SIDEBARBORDER,						COLOR_SIDEBARBACK1},
< 				{COLOR_PROGRAMGUIDECURCHANNELBACK1,			COLOR_PROGRAMGUIDECHANNELBACK1},
< 				{COLOR_PROGRAMGUIDECURCHANNELBACK2,			COLOR_PROGRAMGUIDECHANNELBACK2},
< 				{COLOR_PROGRAMGUIDECURCHANNELTEXT,			COLOR_PROGRAMGUIDECHANNELTEXT},
< 				{COLOR_PROGRAMGUIDETIMELINE,				COLOR_PROGRAMGUIDETIMETEXT},
646,649d283
< 				{COLOR_PANELTITLEBORDER,	COLOR_PANELTITLEBACK1,		COLOR_PANELTITLEBACK2},
< 				{COLOR_TITLEBARBORDER,		COLOR_TITLEBARBACK1,		COLOR_TITLEBARBACK2},
< 				{COLOR_SIDEBARCHECKBORDER,	COLOR_SIDEBARCHECKBACK1,	COLOR_SIDEBARCHECKBACK2},
< 				{COLOR_SIDEBARBORDER,		COLOR_SIDEBARBACK1,			COLOR_SIDEBARBACK2},
683,691d316
< 		} else {
< 			switch (i) {
< 			case GRADIENT_TITLEBARICON:
< 				m_GradientList[i].Type=m_GradientList[GRADIENT_TITLEBARBACK].Type;
< 				break;
< 			case GRADIENT_SIDEBARCHECKBACK:
< 				m_GradientList[i].Type=m_GradientList[GRADIENT_SIDEBARBACK].Type;
< 				break;
< 			}
704,712d328
< 		} else {
< 			switch (i) {
< 			case GRADIENT_TITLEBARICON:
< 				m_GradientList[i].Direction=m_GradientList[GRADIENT_TITLEBARBACK].Direction;
< 				break;
< 			case GRADIENT_SIDEBARCHECKBACK:
< 				m_GradientList[i].Direction=m_GradientList[GRADIENT_SIDEBARBACK].Direction;
< 				break;
< 			}
715a332,333
> 	Settings.Close();
> 
718c336
< 	if (Settings.SetSection(TEXT("Style"))) {
---
> 	if (Settings.Open(pszFileName,TEXT("Style"),CSettings::OPEN_READ)) {
731a350
> 		Settings.Close();
734,780d352
< 	return true;
< }
< 
< 
< bool CColorScheme::Save(CSettings &Settings) const
< {
< 	int i;
< 
< 	if (!Settings.SetSection(TEXT("ColorScheme")))
< 		return false;
< 	Settings.Write(TEXT("Name"),m_Name.GetSafe());
< 	for (i=0;i<NUM_COLORS;i++)
< 		Settings.WriteColor(m_ColorInfoList[i].pszText,m_ColorList[i]);
< 	for (i=0;i<NUM_GRADIENTS;i++) {
< 		static const LPCTSTR pszTypeName[] = {
< 			TEXT("normal"),	TEXT("glossy"), TEXT("interlaced")
< 		};
< 		TCHAR szName[128];
< 
< 		Settings.Write(m_GradientInfoList[i].pszText,pszTypeName[m_GradientList[i].Type]);
< 		::wsprintf(szName,TEXT("%sDirection"),m_GradientInfoList[i].pszText);
< 		Settings.Write(szName,GradientDirectionList[m_GradientList[i].Direction]);
< 	}
< 
< 	if (Settings.SetSection(TEXT("Style"))) {
< 		static const LPCTSTR pszTypeName[] = {
< 			TEXT("none"),	TEXT("solid"),	TEXT("sunken"),	TEXT("raised")
< 		};
< 
< 		for (i=0;i<NUM_BORDERS;i++)
< 			Settings.Write(m_BorderInfoList[i].pszText,pszTypeName[m_BorderList[i]]);
< 	}
< 
< 	return true;
< }
< 
< 
< bool CColorScheme::Load(LPCTSTR pszFileName)
< {
< 	CSettings Settings;
< 
< 	if (!Settings.Open(pszFileName,CSettings::OPEN_READ))
< 		return false;
< 
< 	if (!Load(Settings))
< 		return false;
< 
782,789d353
< 
< 	if (m_Name.IsEmpty()) {
< 		TCHAR szName[MAX_COLORSCHEME_NAME];
< 		::lstrcpyn(szName,::PathFindFileName(pszFileName),lengthof(szName));
< 		::PathRemoveExtension(szName);
< 		SetName(szName);
< 	}
< 
794,804d357
< bool CColorScheme::Save(LPCTSTR pszFileName) const
< {
< 	CSettings Settings;
< 
< 	if (!Settings.Open(pszFileName,CSettings::OPEN_WRITE))
< 		return false;
< 
< 	return Save(Settings);
< }
< 
< 
807c360,364
< 	return m_FileName.Set(pszFileName);
---
> 	if (pszFileName) {
> 		m_FileName=pszFileName;
> 		return true;
> 	}
> 	return false;
920,1841d476
< }
< 
< 
< 
< 
< CColorSchemeList::CColorSchemeList()
< {
< }
< 
< 
< CColorSchemeList::~CColorSchemeList()
< {
< 	Clear();
< }
< 
< 
< bool CColorSchemeList::Add(CColorScheme *pColorScheme)
< {
< 	if (pColorScheme==NULL)
< 		return false;
< 	m_List.push_back(pColorScheme);
< 	return true;
< }
< 
< 
< bool CColorSchemeList::Insert(int Index,CColorScheme *pColorScheme)
< {
< 	if (Index<0)
< 		return false;
< 	if ((size_t)Index>=m_List.size())
< 		return Add(pColorScheme);
< 	auto i=m_List.begin();
< 	std::advance(i,Index);
< 	m_List.insert(i,pColorScheme);
< 	return true;
< }
< 
< 
< bool CColorSchemeList::Load(LPCTSTR pszDirectory)
< {
< 	HANDLE hFind;
< 	WIN32_FIND_DATA wfd;
< 	TCHAR szFileName[MAX_PATH];
< 
< 	::PathCombine(szFileName,pszDirectory,TEXT("*.httheme"));
< 	hFind=::FindFirstFile(szFileName,&wfd);
< 	if (hFind!=INVALID_HANDLE_VALUE) {
< 		do {
< 			CColorScheme *pColorScheme;
< 
< 			::PathCombine(szFileName,pszDirectory,wfd.cFileName);
< 			pColorScheme=new CColorScheme;
< 			if (pColorScheme->Load(szFileName))
< 				Add(pColorScheme);
< 			else
< 				delete pColorScheme;
< 		} while (::FindNextFile(hFind,&wfd));
< 		::FindClose(hFind);
< 	}
< 	return true;
< }
< 
< 
< void CColorSchemeList::Clear()
< {
< 	for (auto i=m_List.begin();i!=m_List.end();i++)
< 		delete *i;
< 	m_List.clear();
< }
< 
< 
< CColorScheme *CColorSchemeList::GetColorScheme(int Index)
< {
< 	if (Index<0 || (size_t)Index>=m_List.size())
< 		return NULL;
< 	return m_List[Index];
< }
< 
< 
< bool CColorSchemeList::SetColorScheme(int Index,const CColorScheme *pColorScheme)
< {
< 	if (Index<0 || (size_t)Index>=m_List.size() || pColorScheme==NULL)
< 		return false;
< 	*m_List[Index]=*pColorScheme;
< 	return true;
< }
< 
< 
< int CColorSchemeList::FindByName(LPCTSTR pszName,int FirstIndex) const
< {
< 	if (pszName==NULL)
< 		return -1;
< 
< 	for (int i=max(FirstIndex,0);i<(int)m_List.size();i++) {
< 		if (m_List[i]->GetName()!=NULL
< 				&& ::lstrcmpi(m_List[i]->GetName(),pszName)==0)
< 			return i;
< 	}
< 	return -1;
< }
< 
< 
< void CColorSchemeList::SortByName()
< {
< 	if (m_List.size()>1) {
< 		class CPredicator
< 		{
< 		public:
< 			bool operator()(const CColorScheme *pColorScheme1,
< 							const CColorScheme *pColorScheme2) const
< 			{
< 				LPCTSTR pszName1=pColorScheme1->GetName();
< 				if (pszName1==NULL)
< 					pszName1=TEXT("");
< 
< 				LPCTSTR pszName2=pColorScheme2->GetName();
< 				if (pszName2==NULL)
< 					pszName2=TEXT("");
< 
< 				return ::lstrcmpi(pszName1,pszName2)<0;
< 			}
< 		};
< 
< 		std::sort(m_List.begin(),m_List.end(),CPredicator());
< 	}
< }
< 
< 
< 
< 
< const LPCTSTR CColorSchemeOptions::m_pszExtension=TEXT(".httheme");
< 
< 
< CColorSchemeOptions::CColorSchemeOptions()
< 	: m_pColorScheme(new CColorScheme)
< 	, m_pPreviewColorScheme(NULL)
< 	, m_pApplyFunc(NULL)
< {
< }
< 
< 
< CColorSchemeOptions::~CColorSchemeOptions()
< {
< 	Destroy();
< 	delete m_pColorScheme;
< 	delete m_pPreviewColorScheme;
< }
< 
< 
< bool CColorSchemeOptions::LoadSettings(CSettings &Settings)
< {
< 	return m_pColorScheme->Load(Settings);
< }
< 
< 
< bool CColorSchemeOptions::SaveSettings(CSettings &Settings)
< {
< 	return m_pColorScheme->Save(Settings);
< }
< 
< 
< bool CColorSchemeOptions::Create(HWND hwndOwner)
< {
< 	return CreateDialogWindow(hwndOwner,
< 							  GetAppClass().GetResourceInstance(),MAKEINTRESOURCE(IDD_OPTIONS_COLORSCHEME));
< }
< 
< 
< bool CColorSchemeOptions::SetApplyCallback(ApplyFunc pCallback)
< {
< 	m_pApplyFunc=pCallback;
< 	return true;
< }
< 
< 
< bool CColorSchemeOptions::ApplyColorScheme() const
< {
< 	return Apply(m_pColorScheme);
< }
< 
< 
< bool CColorSchemeOptions::Apply(const CColorScheme *pColorScheme) const
< {
< 	if (m_pApplyFunc==NULL)
< 		return false;
< 	return m_pApplyFunc(pColorScheme);
< }
< 
< 
< COLORREF CColorSchemeOptions::GetColor(int Type) const
< {
< 	if (m_pPreviewColorScheme!=NULL)
< 		return m_pPreviewColorScheme->GetColor(Type);
< 	return m_pColorScheme->GetColor(Type);
< }
< 
< 
< COLORREF CColorSchemeOptions::GetColor(LPCTSTR pszText) const
< {
< 	if (m_pPreviewColorScheme!=NULL)
< 		return m_pPreviewColorScheme->GetColor(pszText);
< 	return m_pColorScheme->GetColor(pszText);
< }
< 
< 
< void CColorSchemeOptions::GetCurrentSettings(CColorScheme *pColorScheme)
< {
< 	int i;
< 
< 	for (i=0;i<CColorScheme::NUM_COLORS;i++)
< 		pColorScheme->SetColor(i,
< 							   (COLORREF)DlgListBox_GetItemData(m_hDlg,IDC_COLORSCHEME_LIST,i));
< 	for (int i=0;i<CColorScheme::NUM_GRADIENTS;i++)
< 		pColorScheme->SetGradientStyle(i,m_GradientList[i]);
< 	for (int i=0;i<CColorScheme::NUM_BORDERS;i++)
< 		pColorScheme->SetBorderType(i,m_BorderList[i]);
< }
< 
< 
< bool CColorSchemeOptions::GetThemesDirectory(LPTSTR pszDirectory,int MaxLength,bool fCreate)
< {
< 	GetAppClass().GetAppDirectory(pszDirectory);
< 	::PathAppend(pszDirectory,TEXT("Themes"));
< 	if (fCreate && !::PathIsDirectory(pszDirectory))
< 		::CreateDirectory(pszDirectory,NULL);
< 	return true;
< }
< 
< 
< INT_PTR CColorSchemeOptions::DlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
< {
< 	switch (uMsg) {
< 	case WM_INITDIALOG:
< 		{
< 			TCHAR szDirectory[MAX_PATH];
< 			int i;
< 
< 			GetThemesDirectory(szDirectory,lengthof(szDirectory));
< 			m_PresetList.Load(szDirectory);
< 			//m_PresetList.SortByName();
< 			CColorScheme *pColorScheme=new CColorScheme(*m_pColorScheme);
< 			pColorScheme->SetName(TEXT("現在のテーマ"));
< 			pColorScheme->SetLoaded();
< 			m_PresetList.Insert(0,pColorScheme);
< 			pColorScheme=new CColorScheme;
< 			pColorScheme->SetName(TEXT("デフォルトのテーマ"));
< 			pColorScheme->SetLoaded();
< 			m_PresetList.Insert(1,pColorScheme);
< 			for (i=0;i<m_PresetList.NumColorSchemes();i++) {
< 				DlgComboBox_AddItem(hDlg,IDC_COLORSCHEME_PRESET,i);
< 			}
< 			int Height=7*HIWORD(::GetDialogBaseUnits())/8+6;
< 			DlgComboBox_SetItemHeight(hDlg,IDC_COLORSCHEME_PRESET,0,Height);
< 			DlgComboBox_SetItemHeight(hDlg,IDC_COLORSCHEME_PRESET,-1,Height);
< 			DlgComboBox_SetCurSel(hDlg,IDC_COLORSCHEME_PRESET,0);
< 			EnableDlgItem(hDlg,IDC_COLORSCHEME_DELETE,false);
< 
< 			for (i=0;i<CColorScheme::NUM_COLORS;i++) {
< 				DlgListBox_AddItem(hDlg,IDC_COLORSCHEME_LIST,m_pColorScheme->GetColor(i));
< 			}
< 			HDC hdc=GetDC(GetDlgItem(hDlg,IDC_COLORSCHEME_LIST));
< 			HFONT hfontOld=
< 				SelectFont(hdc,(HFONT)SendDlgItemMessage(hDlg,IDC_COLORSCHEME_LIST,WM_GETFONT,0,0));
< 			long MaxWidth=0;
< 			for (i=0;i<CColorScheme::NUM_COLORS;i++) {
< 				LPCTSTR pszName=CColorScheme::GetColorName(i);
< 				RECT rc={0,0,0,0};
< 				::DrawText(hdc,pszName,-1,&rc,DT_SINGLELINE | DT_NOPREFIX | DT_CALCRECT);
< 				if (rc.right>MaxWidth)
< 					MaxWidth=rc.right;
< 			}
< 			SelectFont(hdc,hfontOld);
< 			ReleaseDC(GetDlgItem(hDlg,IDC_COLORSCHEME_LIST),hdc);
< 			DlgListBox_SetItemHeight(hDlg,IDC_COLORSCHEME_LIST,0,
< 									 7*HIWORD(::GetDialogBaseUnits())/8);
< 			DlgListBox_SetHorizontalExtent(hDlg,IDC_COLORSCHEME_LIST,
< 										   DlgListBox_GetItemHeight(hDlg,IDC_COLORSCHEME_LIST,0)*2+MaxWidth+2);
< 			ExtendListBox(GetDlgItem(hDlg,IDC_COLORSCHEME_LIST));
< 
< 			for (int i=0;i<CColorScheme::NUM_GRADIENTS;i++)
< 				m_pColorScheme->GetGradientStyle(i,&m_GradientList[i]);
< 			for (int i=0;i<CColorScheme::NUM_BORDERS;i++)
< 				m_BorderList[i]=m_pColorScheme->GetBorderType(i);
< 
< 			RECT rc;
< 			static const RGBQUAD BaseColors[18] = {
< 				{0x00, 0x00, 0xFF},
< 				{0x00, 0x66, 0xFF},
< 				{0x00, 0xCC, 0xFF},
< 				{0x00, 0xFF, 0xFF},
< 				{0x00, 0xFF, 0xCC},
< 				{0x00, 0xFF, 0x66},
< 				{0x00, 0xFF, 0x00},
< 				{0x66, 0xFF, 0x00},
< 				{0xCC, 0xFF, 0x00},
< 				{0xFF, 0xFF, 0x00},
< 				{0xFF, 0xCC, 0x00},
< 				{0xFF, 0x66, 0x00},
< 				{0xFF, 0x00, 0x00},
< 				{0xFF, 0x00, 0x66},
< 				{0xFF, 0x00, 0xCC},
< 				{0xFF, 0x00, 0xFF},
< 				{0xCC, 0x00, 0xFF},
< 				{0x66, 0x00, 0xFF},
< 			};
< 			RGBQUAD Palette[256];
< 			int j,k;
< 
< 			CColorPalette::Initialize(GetWindowInstance(hDlg));
< 			m_ColorPalette.Create(hDlg,WS_CHILD | WS_VISIBLE,0,IDC_COLORSCHEME_PALETTE);
< 			GetWindowRect(GetDlgItem(hDlg,IDC_COLORSCHEME_PALETTEPLACE),&rc);
< 			MapWindowPoints(NULL,hDlg,(LPPOINT)&rc,2);
< 			m_ColorPalette.SetPosition(&rc);
< 			for (i=0;i<lengthof(BaseColors);i++) {
< 				RGBQUAD Color=BaseColors[i%2*(lengthof(BaseColors)/2)+i/2];
< 
< 				for (j=0;j<4;j++) {
< 					Palette[i*8+j].rgbBlue=(Color.rgbBlue*(j+1))/4;
< 					Palette[i*8+j].rgbGreen=(Color.rgbGreen*(j+1))/4;
< 					Palette[i*8+j].rgbRed=(Color.rgbRed*(j+1))/4;
< 				}
< 				for (;j<8;j++) {
< 					Palette[i*8+j].rgbBlue=Color.rgbBlue+(255-Color.rgbBlue)*(j-3)/5;
< 					Palette[i*8+j].rgbGreen=Color.rgbGreen+(255-Color.rgbGreen)*(j-3)/5;
< 					Palette[i*8+j].rgbRed=Color.rgbRed+(255-Color.rgbRed)*(j-3)/5;
< 				}
< 			}
< 			i=lengthof(BaseColors)*8;
< 			for (j=0;j<16;j++) {
< 				Palette[i].rgbBlue=(255*j)/15;
< 				Palette[i].rgbGreen=(255*j)/15;
< 				Palette[i].rgbRed=(255*j)/15;
< 				i++;
< 			}
< 			for (j=0;j<CColorScheme::NUM_COLORS;j++) {
< 				COLORREF cr=m_pColorScheme->GetColor(j);
< 
< 				for (k=0;k<i;k++) {
< 					if (cr==RGB(Palette[k].rgbRed,Palette[k].rgbGreen,Palette[k].rgbBlue))
< 						break;
< 				}
< 				if (k==i) {
< 					Palette[i].rgbBlue=GetBValue(cr);
< 					Palette[i].rgbGreen=GetGValue(cr);
< 					Palette[i].rgbRed=GetRValue(cr);
< 					i++;
< 				}
< 			}
< 			if (i<lengthof(Palette))
< 				ZeroMemory(&Palette[i],(lengthof(Palette)-i)*sizeof(RGBQUAD));
< 			m_ColorPalette.SetPalette(Palette,lengthof(Palette));
< 		}
< 		return TRUE;
< 
< 	/*
< 	case WM_MEASUREITEM:
< 		{
< 			LPMEASUREITEMSTRUCT pmis=reinterpret_cast<LPMEASUREITEMSTRUCT>(lParam);
< 
< 			pmis->itemHeight=7*HIWORD(GetDialogBaseUnits())/8;
< 			if (pmis->CtlID==IDC_COLORSCHEME_PRESET)
< 				pmis->itemHeight+=6;
< 		}
< 		return TRUE;
< 	*/
< 
< 	case WM_DRAWITEM:
< 		{
< 			LPDRAWITEMSTRUCT pdis=reinterpret_cast<LPDRAWITEMSTRUCT>(lParam);
< 
< 			if (pdis->CtlID==IDC_COLORSCHEME_PRESET) {
< 				switch (pdis->itemAction) {
< 				case ODA_DRAWENTIRE:
< 				case ODA_SELECT:
< 					if ((int)pdis->itemID<0) {
< 						::FillRect(pdis->hDC,&pdis->rcItem,
< 								   reinterpret_cast<HBRUSH>(COLOR_WINDOW+1));
< 					} else {
< 						const CColorScheme *pColorScheme=m_PresetList.GetColorScheme((int)pdis->itemData);
< 						if (pColorScheme==NULL)
< 							break;
< 						bool fSelected=(pdis->itemState & ODS_SELECTED)!=0
< 									&& (pdis->itemState & ODS_COMBOBOXEDIT)==0;
< 						Theme::Style Style;
< 
< 						pColorScheme->GetStyle(fSelected?
< 											   CColorScheme::STYLE_STATUSHIGHLIGHTITEM:
< 											   CColorScheme::STYLE_STATUSITEM,
< 											   &Style);
< 						Theme::DrawStyleBackground(pdis->hDC,&pdis->rcItem,&Style);
< 						if (!IsStringEmpty(pColorScheme->GetName())) {
< 							int OldBkMode;
< 							COLORREF crOldTextColor;
< 							RECT rc;
< 							HFONT hfont,hfontOld;
< 
< 							if (fSelected) {
< 								LOGFONT lf;
< 
< 								hfontOld=static_cast<HFONT>(::GetCurrentObject(pdis->hDC,OBJ_FONT));
< 								::GetObject(hfontOld,sizeof(LOGFONT),&lf);
< 								lf.lfWeight=FW_BOLD;
< 								hfont=::CreateFontIndirect(&lf);
< 								SelectFont(pdis->hDC,hfont);
< 							} else {
< 								hfont=NULL;
< 							}
< 							OldBkMode=::SetBkMode(pdis->hDC,TRANSPARENT);
< 							crOldTextColor=::SetTextColor(pdis->hDC,Style.TextColor);
< 							rc=pdis->rcItem;
< 							rc.left+=4;
< 							::DrawText(pdis->hDC,pColorScheme->GetName(),-1,&rc,
< 								DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX | DT_END_ELLIPSIS);
< 							::SetTextColor(pdis->hDC,crOldTextColor);
< 							::SetBkMode(pdis->hDC,OldBkMode);
< 							if (hfont!=NULL) {
< 								::SelectObject(pdis->hDC,hfontOld);
< 								::DeleteObject(hfont);
< 							}
< 						}
< 					}
< 					if ((pdis->itemState & ODS_FOCUS)==0)
< 						break;
< 				case ODA_FOCUS:
< 					if ((pdis->itemState & ODS_NOFOCUSRECT)==0
< 							&& (pdis->itemState & ODS_COMBOBOXEDIT)!=0)
< 						::DrawFocusRect(pdis->hDC,&pdis->rcItem);
< 					break;
< 				}
< 			} else if (pdis->CtlID==IDC_COLORSCHEME_LIST) {
< 				switch (pdis->itemAction) {
< 				case ODA_DRAWENTIRE:
< 				case ODA_SELECT:
< 					{
< 						int BackSysColor;
< 						COLORREF BackColor,TextColor,OldTextColor;
< 						HBRUSH hbr,hbrOld;
< 						HPEN hpenOld;
< 						RECT rc;
< 						int OldBkMode;
< 
< 						if ((pdis->itemState & ODS_SELECTED)==0) {
< 							BackSysColor=COLOR_WINDOW;
< 							TextColor=::GetSysColor(COLOR_WINDOWTEXT);
< 						} else {
< 							BackSysColor=COLOR_HIGHLIGHT;
< 							TextColor=::GetSysColor(COLOR_HIGHLIGHTTEXT);
< 						}
< 						BackColor=::GetSysColor(BackSysColor);
< 						int Border=CColorScheme::GetColorBorder((int)pdis->itemID);
< 						if (Border>=0 && m_BorderList[Border]==Theme::BORDER_NONE)
< 							TextColor=MixColor(TextColor,BackColor);
< 						::FillRect(pdis->hDC,&pdis->rcItem,reinterpret_cast<HBRUSH>(BackSysColor+1));
< 						hbr=::CreateSolidBrush((COLORREF)pdis->itemData);
< 						hbrOld=SelectBrush(pdis->hDC,hbr);
< 						hpenOld=SelectPen(pdis->hDC,::GetStockObject(BLACK_PEN));
< 						rc.left=pdis->rcItem.left+2;
< 						rc.top=pdis->rcItem.top+2;
< 						rc.bottom=pdis->rcItem.bottom-2;
< 						rc.right=rc.left+(rc.bottom-rc.top)*2;
< 						::Rectangle(pdis->hDC,rc.left,rc.top,rc.right,rc.bottom);
< 						::SelectObject(pdis->hDC,hpenOld);
< 						::SelectObject(pdis->hDC,hbrOld);
< 						::DeleteObject(hbr);
< 						OldBkMode=::SetBkMode(pdis->hDC,TRANSPARENT);
< 						OldTextColor=::SetTextColor(pdis->hDC,TextColor);
< 						rc.left=rc.right+2;
< 						rc.top=pdis->rcItem.top;
< 						rc.right=pdis->rcItem.right;
< 						rc.bottom=pdis->rcItem.bottom;
< 						::DrawText(pdis->hDC,CColorScheme::GetColorName(pdis->itemID),-1,&rc,
< 								   DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
< 						::SetTextColor(pdis->hDC,OldTextColor);
< 						::SetBkMode(pdis->hDC,OldBkMode);
< 					}
< 					if ((pdis->itemState & ODS_FOCUS)==0)
< 						break;
< 				case ODA_FOCUS:
< 					if ((pdis->itemState & ODS_NOFOCUSRECT)==0)
< 						::DrawFocusRect(pdis->hDC,&pdis->rcItem);
< 					break;
< 				}
< 			}
< 		}
< 		return TRUE;
< 
< 	case WM_COMPAREITEM:
< 		{
< 			COMPAREITEMSTRUCT *pcis=reinterpret_cast<COMPAREITEMSTRUCT*>(lParam);
< 
< 			if (pcis->CtlID==IDC_COLORSCHEME_PRESET) {
< 				if (pcis->itemData1<2 || pcis->itemData2<2)
< 					return (int)pcis->itemData1-(int)pcis->itemData2;
< 
< 				const CColorScheme *pColorScheme1=m_PresetList.GetColorScheme((int)pcis->itemData1);
< 				const CColorScheme *pColorScheme2=m_PresetList.GetColorScheme((int)pcis->itemData2);
< 				if (pColorScheme1==NULL || pColorScheme2==NULL)
< 					return 0;
< 
< 				LPCTSTR pszName1=pColorScheme1->GetName();
< 				if (pszName1==NULL)
< 					pszName1=TEXT("");
< 
< 				LPCTSTR pszName2=pColorScheme2->GetName();
< 				if (pszName2==NULL)
< 					pszName2=TEXT("");
< 
< 				int Cmp=::CompareString(pcis->dwLocaleId,NORM_IGNORECASE,pszName1,-1,pszName2,-1);
< 				if (Cmp!=0)
< 					Cmp-=CSTR_EQUAL;
< 				return Cmp;
< 			}
< 		}
< 		return 0;
< 
< 	case WM_COMMAND:
< 		switch (LOWORD(wParam)) {
< 		case IDC_COLORSCHEME_PRESET:
< 			if (HIWORD(wParam)==CBN_SELCHANGE) {
< 				int Sel=(int)DlgComboBox_GetCurSel(hDlg,IDC_COLORSCHEME_PRESET);
< 
< 				if (Sel>=0) {
< 					int Index=(int)DlgComboBox_GetItemData(hDlg,IDC_COLORSCHEME_PRESET,Sel);
< 					const CColorScheme *pColorScheme=m_PresetList.GetColorScheme(Index);
< 
< 					if (pColorScheme!=NULL) {
< 						int i;
< 
< 						for (i=0;i<CColorScheme::NUM_COLORS;i++) {
< 							if (pColorScheme->IsLoaded(i))
< 								SendDlgItemMessage(hDlg,IDC_COLORSCHEME_LIST,
< 									LB_SETITEMDATA,i,pColorScheme->GetColor(i));
< 						}
< 						SendDlgItemMessage(hDlg,IDC_COLORSCHEME_LIST,LB_SETSEL,FALSE,-1);
< 						InvalidateDlgItem(hDlg,IDC_COLORSCHEME_LIST);
< 
< 						for (i=0;i<CColorScheme::NUM_GRADIENTS;i++)
< 							pColorScheme->GetGradientStyle(i,&m_GradientList[i]);
< 						for (i=0;i<CColorScheme::NUM_BORDERS;i++)
< 							m_BorderList[i]=pColorScheme->GetBorderType(i);
< 
< 						m_ColorPalette.SetSel(-1);
< 						::SendMessage(hDlg,WM_COMMAND,IDC_COLORSCHEME_PREVIEW,0);
< 					}
< 				}
< 
< 				EnableDlgItem(hDlg,IDC_COLORSCHEME_DELETE,Sel>=2);
< 			}
< 			return TRUE;
< 
< 		case IDC_COLORSCHEME_SAVE:
< 			{
< 				CColorScheme *pColorScheme;
< 				TCHAR szName[MAX_COLORSCHEME_NAME];
< 				szName[0]=_T('\0');
< 				LRESULT Sel=DlgComboBox_GetCurSel(hDlg,IDC_COLORSCHEME_PRESET);
< 				if (Sel>=2) {
< 					pColorScheme=m_PresetList.GetColorScheme(
< 						(int)DlgComboBox_GetItemData(hDlg,IDC_COLORSCHEME_PRESET,Sel));
< 					if (pColorScheme!=NULL && pColorScheme->GetName()!=NULL)
< 						::lstrcpyn(szName,pColorScheme->GetName(),lengthof(szName));
< 				}
< 				if (::DialogBoxParam(GetAppClass().GetResourceInstance(),
< 									 MAKEINTRESOURCE(IDD_SAVECOLORSCHEME),
< 									 hDlg,SaveDlgProc,reinterpret_cast<LPARAM>(szName))!=IDOK)
< 					return TRUE;
< 
< 				pColorScheme=NULL;
< 				int Index=m_PresetList.FindByName(szName,2);
< 				if (Index>=2) {
< 					pColorScheme=m_PresetList.GetColorScheme(Index);
< 				}
< 				bool fNewColorScheme;
< 				TCHAR szFileName[MAX_PATH];
< 				if (pColorScheme!=NULL && !IsStringEmpty(pColorScheme->GetFileName())) {
< 					::lstrcpy(szFileName,pColorScheme->GetFileName());
< 					fNewColorScheme=false;
< 				} else {
< 					GetThemesDirectory(szFileName,lengthof(szFileName),true);
< 					if (::lstrlen(szFileName)+1+::lstrlen(szName)+::lstrlen(m_pszExtension)>=MAX_PATH) {
< 						MessageBox(hDlg,TEXT("名前が長すぎます。"),NULL,MB_OK | MB_ICONEXCLAMATION);
< 						break;
< 					}
< 					::PathAppend(szFileName,szName);
< 					::lstrcat(szFileName,m_pszExtension);
< 					pColorScheme=new CColorScheme;
< 					pColorScheme->SetFileName(szFileName);
< 					fNewColorScheme=true;
< 				}
< 				pColorScheme->SetName(szName);
< 				pColorScheme->SetLoaded();
< 
< 				GetCurrentSettings(pColorScheme);
< 				if (!pColorScheme->Save(szFileName)) {
< 					if (fNewColorScheme)
< 						delete pColorScheme;
< 					::MessageBox(hDlg,TEXT("保存ができません。"),NULL,MB_OK | MB_ICONEXCLAMATION);
< 					break;
< 				}
< 
< 				if (fNewColorScheme) {
< 					m_PresetList.Add(pColorScheme);
< 					Index=(int)DlgComboBox_AddItem(hDlg,IDC_COLORSCHEME_PRESET,m_PresetList.NumColorSchemes()-1);
< 				} else {
< 					InvalidateDlgItem(hDlg,IDC_COLORSCHEME_PRESET);
< 					int ItemCount=DlgComboBox_GetCount(hDlg,IDC_COLORSCHEME_PRESET);
< 					for (int i=2;i<ItemCount;i++) {
< 						if (DlgComboBox_GetItemData(hDlg,IDC_COLORSCHEME_PRESET,i)==Index) {
< 							Index=i;
< 							break;
< 						}
< 					}
< 				}
< 				DlgComboBox_SetCurSel(hDlg,IDC_COLORSCHEME_PRESET,Index);
< 
< 				::MessageBox(hDlg,TEXT("テーマを保存しました。"),TEXT("保存"),MB_OK | MB_ICONINFORMATION);
< 			}
< 			return TRUE;
< 
< 		case IDC_COLORSCHEME_DELETE:
< 			{
< 				LRESULT Sel=DlgComboBox_GetCurSel(hDlg,IDC_COLORSCHEME_PRESET);
< 				if (Sel<2)
< 					break;
< 				CColorScheme *pColorScheme=m_PresetList.GetColorScheme(
< 					(int)DlgComboBox_GetItemData(hDlg,IDC_COLORSCHEME_PRESET,Sel));
< 				if (pColorScheme==NULL || IsStringEmpty(pColorScheme->GetFileName()))
< 					break;
< 				if (::MessageBox(hDlg,TEXT("選択されたテーマを削除しますか?"),TEXT("削除の確認"),
< 								 MB_OKCANCEL | MB_ICONQUESTION)!=IDOK)
< 					break;
< 				if (!::DeleteFile(pColorScheme->GetFileName())) {
< 					::MessageBox(hDlg,TEXT("ファイルを削除できません。"),NULL,MB_OK | MB_ICONEXCLAMATION);
< 					break;
< 				}
< 				DlgComboBox_DeleteItem(hDlg,IDC_COLORSCHEME_PRESET,Sel);
< 			}
< 			return TRUE;
< 
< 		case IDC_COLORSCHEME_LIST:
< 			switch (HIWORD(wParam)) {
< 			case LBN_SELCHANGE:
< 				{
< 					int SelCount=(int)DlgListBox_GetSelCount(hDlg,IDC_COLORSCHEME_LIST);
< 					int i;
< 					COLORREF SelColor=CLR_INVALID,Color;
< 
< 					if (SelCount==0) {
< 						m_ColorPalette.SetSel(-1);
< 						break;
< 					}
< 					if (SelCount==1) {
< 						for (i=0;i<CColorScheme::NUM_COLORS;i++) {
< 							if (DlgListBox_GetSel(hDlg,IDC_COLORSCHEME_LIST,i)) {
< 								SelColor=(COLORREF)DlgListBox_GetItemData(hDlg,IDC_COLORSCHEME_LIST,i);
< 								break;
< 							}
< 						}
< 					} else {
< 						for (i=0;i<CColorScheme::NUM_COLORS;i++) {
< 							if (DlgListBox_GetSel(hDlg,IDC_COLORSCHEME_LIST,i)) {
< 								Color=(COLORREF)DlgListBox_GetItemData(hDlg,IDC_COLORSCHEME_LIST,i);
< 								if (SelColor==CLR_INVALID)
< 									SelColor=Color;
< 								else if (Color!=SelColor)
< 									break;
< 							}
< 						}
< 						if (i<CColorScheme::NUM_COLORS) {
< 							m_ColorPalette.SetSel(-1);
< 							break;
< 						}
< 					}
< 					if (SelColor!=CLR_INVALID)
< 						m_ColorPalette.SetSel(m_ColorPalette.FindColor(SelColor));
< 				}
< 				break;
< 
< 			case LBN_EX_RBUTTONDOWN:
< 				{
< 					HMENU hmenu=::LoadMenu(GetAppClass().GetResourceInstance(),MAKEINTRESOURCE(IDM_COLORSCHEME));
< 					POINT pt;
< 
< 					::EnableMenuItem(hmenu,IDC_COLORSCHEME_SELECTSAMECOLOR,
< 						MF_BYCOMMAND | (m_ColorPalette.GetSel()>=0?MFS_ENABLED:MFS_GRAYED));
< 					if (DlgListBox_GetSelCount(hDlg,IDC_COLORSCHEME_LIST)==1) {
< 						int Sel,Gradient,Border;
< 
< 						DlgListBox_GetSelItems(hDlg,IDC_COLORSCHEME_LIST,&Sel,1);
< 						Gradient=CColorScheme::GetColorGradient(Sel);
< 						if (Gradient>=0) {
< 							::EnableMenuItem(::GetSubMenu(hmenu,0),2,MF_BYPOSITION | MFS_ENABLED);
< 							::CheckMenuRadioItem(hmenu,
< 												 IDC_COLORSCHEME_GRADIENT_NORMAL,IDC_COLORSCHEME_GRADIENT_INTERLACED,
< 												 IDC_COLORSCHEME_GRADIENT_NORMAL+(int)m_GradientList[Gradient].Type,
< 												 MF_BYCOMMAND);
< 							::EnableMenuItem(::GetSubMenu(hmenu,0),3,MF_BYPOSITION | MFS_ENABLED);
< 							::CheckMenuRadioItem(hmenu,
< 												 IDC_COLORSCHEME_DIRECTION_HORZ,IDC_COLORSCHEME_DIRECTION_VERTMIRROR,
< 												 IDC_COLORSCHEME_DIRECTION_HORZ+(int)m_GradientList[Gradient].Direction,
< 												 MF_BYCOMMAND);
< 							if (!CColorScheme::IsGradientDirectionEnabled(Gradient)) {
< 								if (m_GradientList[Gradient].Direction==Theme::DIRECTION_HORZ
< 										|| m_GradientList[Gradient].Direction==Theme::DIRECTION_HORZMIRROR) {
< 									::EnableMenuItem(hmenu,IDC_COLORSCHEME_DIRECTION_VERT,MF_BYCOMMAND | MFS_GRAYED);
< 									::EnableMenuItem(hmenu,IDC_COLORSCHEME_DIRECTION_VERTMIRROR,MF_BYCOMMAND | MFS_GRAYED);
< 								} else {
< 									::EnableMenuItem(hmenu,IDC_COLORSCHEME_DIRECTION_HORZ,MF_BYCOMMAND | MFS_GRAYED);
< 									::EnableMenuItem(hmenu,IDC_COLORSCHEME_DIRECTION_HORZMIRROR,MF_BYCOMMAND | MFS_GRAYED);
< 								}
< 							}
< 						}
< 						Border=CColorScheme::GetColorBorder(Sel);
< 						if (Border>=0) {
< 							::EnableMenuItem(::GetSubMenu(hmenu,0),4,MF_BYPOSITION | MFS_ENABLED);
< 							::EnableMenuItem(hmenu,IDC_COLORSCHEME_BORDER_NONE,
< 											 MF_BYCOMMAND | (CColorScheme::IsBorderAlways(Border)?MFS_GRAYED:MFS_ENABLED));
< 							::CheckMenuRadioItem(hmenu,
< 												 IDC_COLORSCHEME_BORDER_NONE,IDC_COLORSCHEME_BORDER_RAISED,
< 												 IDC_COLORSCHEME_BORDER_NONE+(int)m_BorderList[Border],
< 												 MF_BYCOMMAND);
< 						}
< 					}
< 					::GetCursorPos(&pt);
< 					::TrackPopupMenu(::GetSubMenu(hmenu,0),TPM_RIGHTBUTTON,pt.x,pt.y,0,hDlg,NULL);
< 					::DestroyMenu(hmenu);
< 				}
< 				break;
< 			}
< 			return TRUE;
< 
< 		case IDC_COLORSCHEME_PALETTE:
< 			switch (HIWORD(wParam)) {
< 			case CColorPalette::NOTIFY_SELCHANGE:
< 				{
< 					int Sel=m_ColorPalette.GetSel();
< 					COLORREF Color=m_ColorPalette.GetColor(Sel);
< 					int i;
< 
< 					for (i=0;i<CColorScheme::NUM_COLORS;i++) {
< 						if (DlgListBox_GetSel(hDlg,IDC_COLORSCHEME_LIST,i))
< 							DlgListBox_SetItemData(hDlg,IDC_COLORSCHEME_LIST,i,Color);
< 					}
< 					InvalidateDlgItem(hDlg,IDC_COLORSCHEME_LIST);
< 				}
< 				break;
< 
< 			case CColorPalette::NOTIFY_DOUBLECLICK:
< 				{
< 					int Sel=m_ColorPalette.GetSel();
< 					COLORREF Color=m_ColorPalette.GetColor(Sel);
< 
< 					if (ChooseColorDialog(hDlg,&Color)) {
< 						m_ColorPalette.SetColor(Sel,Color);
< 						int i;
< 
< 						for (i=0;i<CColorScheme::NUM_COLORS;i++) {
< 							if (DlgListBox_GetSel(hDlg,IDC_COLORSCHEME_LIST,i))
< 								DlgListBox_SetItemData(hDlg,IDC_COLORSCHEME_LIST,i,Color);
< 						}
< 						InvalidateDlgItem(hDlg,IDC_COLORSCHEME_LIST);
< 					}
< 				}
< 				break;
< 			}
< 			return TRUE;
< 
< #if 0
< 		case IDC_COLORSCHEME_DEFAULT:
< 			{
< 				int i;
< 
< 				for (i=0;i<CColorScheme::NUM_COLORS;i++)
< 					DlgListBox_SetItemData(hDlg,IDC_COLORSCHEME_LIST,i,
< 										   CColorScheme::GetDefaultColor(i));
< 				for (i=0;i<CColorScheme::NUM_GRADIENTS;i++)
< 					CColorScheme::GetDefaultGradientStyle(i,&m_GradientList[i]);
< 				for (i=0;i<CColorScheme::NUM_BORDERS;i++)
< 					m_BorderList[i]=CColorScheme::GetDefaultBorderType(i);
< 				InvalidateDlgItem(hDlg,IDC_COLORSCHEME_LIST);
< 				::SendMessage(hDlg,WM_COMMAND,IDC_COLORSCHEME_PREVIEW,0);
< 			}
< 			return TRUE;
< #endif
< 
< 		case IDC_COLORSCHEME_PREVIEW:
< 			if (m_pPreviewColorScheme==NULL)
< 				m_pPreviewColorScheme=new CColorScheme;
< 			GetCurrentSettings(m_pPreviewColorScheme);
< 			Apply(m_pPreviewColorScheme);
< 			return TRUE;
< 
< 		case IDC_COLORSCHEME_SELECTSAMECOLOR:
< 			{
< 				int Sel=m_ColorPalette.GetSel();
< 
< 				if (Sel>=0) {
< 					COLORREF Color=m_ColorPalette.GetColor(Sel);
< 					int TopIndex=(int)DlgListBox_GetTopIndex(hDlg,IDC_COLORSCHEME_LIST);
< 
< 					::SendDlgItemMessage(hDlg,IDC_COLORSCHEME_LIST,WM_SETREDRAW,FALSE,0);
< 					for (int i=0;i<CColorScheme::NUM_COLORS;i++) {
< 						DlgListBox_SetSel(hDlg,IDC_COLORSCHEME_LIST,i,
< 							(COLORREF)DlgListBox_GetItemData(hDlg,IDC_COLORSCHEME_LIST,i)==Color);
< 					}
< 					DlgListBox_SetTopIndex(hDlg,IDC_COLORSCHEME_LIST,TopIndex);
< 					::SendDlgItemMessage(hDlg,IDC_COLORSCHEME_LIST,WM_SETREDRAW,TRUE,0);
< 					::InvalidateDlgItem(hDlg,IDC_COLORSCHEME_LIST);
< 				}
< 			}
< 			return TRUE;
< 
< 		case IDC_COLORSCHEME_GRADIENT_NORMAL:
< 		case IDC_COLORSCHEME_GRADIENT_GLOSSY:
< 		case IDC_COLORSCHEME_GRADIENT_INTERLACED:
< 			if (DlgListBox_GetSelCount(hDlg,IDC_COLORSCHEME_LIST)==1) {
< 				int Sel,Gradient;
< 
< 				DlgListBox_GetSelItems(hDlg,IDC_COLORSCHEME_LIST,&Sel,1);
< 				Gradient=CColorScheme::GetColorGradient(Sel);
< 				if (Gradient>=0) {
< 					m_GradientList[Gradient].Type=
< 						(Theme::GradientType)(LOWORD(wParam)-IDC_COLORSCHEME_GRADIENT_NORMAL);
< 				}
< 			}
< 			return TRUE;
< 
< 		case IDC_COLORSCHEME_DIRECTION_HORZ:
< 		case IDC_COLORSCHEME_DIRECTION_VERT:
< 		case IDC_COLORSCHEME_DIRECTION_HORZMIRROR:
< 		case IDC_COLORSCHEME_DIRECTION_VERTMIRROR:
< 			if (DlgListBox_GetSelCount(hDlg,IDC_COLORSCHEME_LIST)==1) {
< 				int Sel,Gradient;
< 
< 				DlgListBox_GetSelItems(hDlg,IDC_COLORSCHEME_LIST,&Sel,1);
< 				Gradient=CColorScheme::GetColorGradient(Sel);
< 				if (Gradient>=0) {
< 					m_GradientList[Gradient].Direction=
< 						(Theme::GradientDirection)(LOWORD(wParam)-IDC_COLORSCHEME_DIRECTION_HORZ);
< 				}
< 			}
< 			return TRUE;
< 
< 		case IDC_COLORSCHEME_BORDER_NONE:
< 		case IDC_COLORSCHEME_BORDER_SOLID:
< 		case IDC_COLORSCHEME_BORDER_SUNKEN:
< 		case IDC_COLORSCHEME_BORDER_RAISED:
< 			if (DlgListBox_GetSelCount(hDlg,IDC_COLORSCHEME_LIST)==1) {
< 				int Sel,Border;
< 
< 				DlgListBox_GetSelItems(hDlg,IDC_COLORSCHEME_LIST,&Sel,1);
< 				Border=CColorScheme::GetColorBorder(Sel);
< 				if (Border>=0) {
< 					m_BorderList[Border]=
< 						(Theme::BorderType)(LOWORD(wParam)-IDC_COLORSCHEME_BORDER_NONE);
< 					RECT rc;
< 					::SendDlgItemMessage(hDlg,IDC_COLORSCHEME_LIST,LB_GETITEMRECT,
< 										 Sel,reinterpret_cast<LPARAM>(&rc));
< 					InvalidateDlgItem(hDlg,IDC_COLORSCHEME_LIST,&rc);
< 				}
< 			}
< 			return TRUE;
< 		}
< 		return TRUE;
< 
< 	case WM_NOTIFY:
< 		switch (((LPNMHDR)lParam)->code) {
< 		case PSN_APPLY:
< 			GetCurrentSettings(m_pColorScheme);
< 			Apply(m_pColorScheme);
< 			m_fChanged=true;
< 			break;
< 
< 		case PSN_RESET:
< 			if (m_pPreviewColorScheme!=NULL)
< 				Apply(m_pColorScheme);
< 			break;
< 		}
< 		break;
< 
< 	case WM_DESTROY:
< 		SAFE_DELETE(m_pPreviewColorScheme);
< 		m_PresetList.Clear();
< 		break;
< 	}
< 
< 	return FALSE;
< }
< 
< 
< INT_PTR CALLBACK CColorSchemeOptions::SaveDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
< {
< 	static LPTSTR pszName;
< 
< 	switch (uMsg) {
< 	case WM_INITDIALOG:
< 		pszName=reinterpret_cast<LPTSTR>(lParam);
< 		DlgEdit_SetText(hDlg,IDC_SAVECOLORSCHEME_NAME,pszName);
< 		DlgEdit_LimitText(hDlg,IDC_SAVECOLORSCHEME_NAME,MAX_COLORSCHEME_NAME);
< 		EnableDlgItem(hDlg,IDOK,pszName[0]!=_T('\0'));
< 		return TRUE;
< 
< 	case WM_COMMAND:
< 		switch (LOWORD(wParam)) {
< 		case IDC_SAVECOLORSCHEME_NAME:
< 			if (HIWORD(wParam)==EN_CHANGE) {
< 				EnableDlgItem(hDlg,IDOK,GetDlgItemTextLength(hDlg,IDC_SAVECOLORSCHEME_NAME)>0);
< 			}
< 			return TRUE;
< 
< 		case IDOK:
< 			::GetDlgItemText(hDlg,IDC_SAVECOLORSCHEME_NAME,pszName,MAX_COLORSCHEME_NAME);
< 			if (pszName[0]==_T('\0'))
< 				return TRUE;
< 		case IDCANCEL:
< 			::EndDialog(hDlg,LOWORD(wParam));
< 			return TRUE;
< 		}
< 		return TRUE;
< 	}
< 
< 	return FALSE;
diff TVTestStatusView_orig/ColorScheme.h ./ColorScheme.h
5,7d4
< #include <vector>
< #include "Options.h"
< #include "ColorPalette.h"
29d25
< 		COLOR_SPLITTER,
31,177c27
< 		COLOR_PANELBACK,
< 		COLOR_PANELTEXT,
< 		COLOR_PANELTABBACK1,
< 		COLOR_PANELTABBACK2,
< 		COLOR_PANELTABTEXT,
< 		COLOR_PANELTABBORDER,
< 		COLOR_PANELCURTABBACK1,
< 		COLOR_PANELCURTABBACK2,
< 		COLOR_PANELCURTABTEXT,
< 		COLOR_PANELCURTABBORDER,
< 		COLOR_PANELTABMARGIN1,
< 		COLOR_PANELTABMARGIN2,
< 		COLOR_PANELTABMARGINBORDER,
< 		COLOR_PANELTABLINE,
< 		COLOR_PANELTITLEBACK1,
< 		COLOR_PANELTITLEBACK2,
< 		COLOR_PANELTITLETEXT,
< 		COLOR_PANELTITLEBORDER,
< 		COLOR_PROGRAMINFOBACK,
< 		COLOR_PROGRAMINFOTEXT,
< 		COLOR_PROGRAMLISTPANEL_EVENTBACK1,
< 		COLOR_PROGRAMLISTPANEL_EVENTBACK2,
< 		COLOR_PROGRAMLISTPANEL_EVENTTEXT,
< 		COLOR_PROGRAMLISTPANEL_EVENTBORDER,
< 		COLOR_PROGRAMLISTPANEL_CUREVENTBACK1,
< 		COLOR_PROGRAMLISTPANEL_CUREVENTBACK2,
< 		COLOR_PROGRAMLISTPANEL_CUREVENTTEXT,
< 		COLOR_PROGRAMLISTPANEL_CUREVENTBORDER,
< 		COLOR_PROGRAMLISTPANEL_TITLEBACK1,
< 		COLOR_PROGRAMLISTPANEL_TITLEBACK2,
< 		COLOR_PROGRAMLISTPANEL_TITLETEXT,
< 		COLOR_PROGRAMLISTPANEL_TITLEBORDER,
< 		COLOR_PROGRAMLISTPANEL_CURTITLEBACK1,
< 		COLOR_PROGRAMLISTPANEL_CURTITLEBACK2,
< 		COLOR_PROGRAMLISTPANEL_CURTITLETEXT,
< 		COLOR_PROGRAMLISTPANEL_CURTITLEBORDER,
< 		COLOR_CHANNELPANEL_CHANNELNAMEBACK1,
< 		COLOR_CHANNELPANEL_CHANNELNAMEBACK2,
< 		COLOR_CHANNELPANEL_CHANNELNAMETEXT,
< 		COLOR_CHANNELPANEL_CHANNELNAMEBORDER,
< 		COLOR_CHANNELPANEL_CURCHANNELNAMEBACK1,
< 		COLOR_CHANNELPANEL_CURCHANNELNAMEBACK2,
< 		COLOR_CHANNELPANEL_CURCHANNELNAMETEXT,
< 		COLOR_CHANNELPANEL_CURCHANNELNAMEBORDER,
< 		COLOR_CHANNELPANEL_EVENTNAME1BACK1,
< 		COLOR_CHANNELPANEL_EVENTNAME1BACK2,
< 		COLOR_CHANNELPANEL_EVENTNAME1TEXT,
< 		COLOR_CHANNELPANEL_EVENTNAME1BORDER,
< 		COLOR_CHANNELPANEL_EVENTNAME2BACK1,
< 		COLOR_CHANNELPANEL_EVENTNAME2BACK2,
< 		COLOR_CHANNELPANEL_EVENTNAME2TEXT,
< 		COLOR_CHANNELPANEL_EVENTNAME2BORDER,
< 		COLOR_CHANNELPANEL_CUREVENTNAME1BACK1,
< 		COLOR_CHANNELPANEL_CUREVENTNAME1BACK2,
< 		COLOR_CHANNELPANEL_CUREVENTNAME1TEXT,
< 		COLOR_CHANNELPANEL_CUREVENTNAME1BORDER,
< 		COLOR_CHANNELPANEL_CUREVENTNAME2BACK1,
< 		COLOR_CHANNELPANEL_CUREVENTNAME2BACK2,
< 		COLOR_CHANNELPANEL_CUREVENTNAME2TEXT,
< 		COLOR_CHANNELPANEL_CUREVENTNAME2BORDER,
< 		COLOR_CONTROLPANELBACK1,
< 		COLOR_CONTROLPANELBACK2,
< 		COLOR_CONTROLPANELTEXT,
< 		COLOR_CONTROLPANELITEMBORDER,
< 		COLOR_CONTROLPANELHIGHLIGHTBACK1,
< 		COLOR_CONTROLPANELHIGHLIGHTBACK2,
< 		COLOR_CONTROLPANELHIGHLIGHTTEXT,
< 		COLOR_CONTROLPANELHIGHLIGHTBORDER,
< 		COLOR_CONTROLPANELMARGIN,
< 		COLOR_CAPTIONPANELBACK,
< 		COLOR_CAPTIONPANELTEXT,
< 		COLOR_TITLEBARBACK1,
< 		COLOR_TITLEBARBACK2,
< 		COLOR_TITLEBARTEXT,
< 		COLOR_TITLEBARTEXTBORDER,
< 		COLOR_TITLEBARICONBACK1,
< 		COLOR_TITLEBARICONBACK2,
< 		COLOR_TITLEBARICON,
< 		COLOR_TITLEBARICONBORDER,
< 		COLOR_TITLEBARHIGHLIGHTBACK1,
< 		COLOR_TITLEBARHIGHLIGHTBACK2,
< 		COLOR_TITLEBARHIGHLIGHTICON,
< 		COLOR_TITLEBARHIGHLIGHTBORDER,
< 		COLOR_TITLEBARBORDER,
< 		COLOR_SIDEBARBACK1,
< 		COLOR_SIDEBARBACK2,
< 		COLOR_SIDEBARICON,
< 		COLOR_SIDEBARITEMBORDER,
< 		COLOR_SIDEBARHIGHLIGHTBACK1,
< 		COLOR_SIDEBARHIGHLIGHTBACK2,
< 		COLOR_SIDEBARHIGHLIGHTICON,
< 		COLOR_SIDEBARHIGHLIGHTBORDER,
< 		COLOR_SIDEBARCHECKBACK1,
< 		COLOR_SIDEBARCHECKBACK2,
< 		COLOR_SIDEBARCHECKICON,
< 		COLOR_SIDEBARCHECKBORDER,
< 		COLOR_SIDEBARBORDER,
< 		COLOR_NOTIFICATIONBARBACK1,
< 		COLOR_NOTIFICATIONBARBACK2,
< 		COLOR_NOTIFICATIONBARTEXT,
< 		COLOR_NOTIFICATIONBARWARNINGTEXT,
< 		COLOR_NOTIFICATIONBARERRORTEXT,
< 		COLOR_PROGRAMGUIDEBACK,
< 		COLOR_PROGRAMGUIDETEXT,
< 		COLOR_PROGRAMGUIDECHANNELBACK1,
< 		COLOR_PROGRAMGUIDECHANNELBACK2,
< 		COLOR_PROGRAMGUIDECHANNELTEXT,
< 		COLOR_PROGRAMGUIDECURCHANNELBACK1,
< 		COLOR_PROGRAMGUIDECURCHANNELBACK2,
< 		COLOR_PROGRAMGUIDECURCHANNELTEXT,
< 		COLOR_PROGRAMGUIDETIMEBACK1,
< 		COLOR_PROGRAMGUIDETIMEBACK2,
< 		COLOR_PROGRAMGUIDETIMEBACK_0TO2_1,
< 		COLOR_PROGRAMGUIDETIMEBACK_0TO2_2,
< 		COLOR_PROGRAMGUIDETIMEBACK_3TO5_1,
< 		COLOR_PROGRAMGUIDETIMEBACK_3TO5_2,
< 		COLOR_PROGRAMGUIDETIMEBACK_6TO8_1,
< 		COLOR_PROGRAMGUIDETIMEBACK_6TO8_2,
< 		COLOR_PROGRAMGUIDETIMEBACK_9TO11_1,
< 		COLOR_PROGRAMGUIDETIMEBACK_9TO11_2,
< 		COLOR_PROGRAMGUIDETIMEBACK_12TO14_1,
< 		COLOR_PROGRAMGUIDETIMEBACK_12TO14_2,
< 		COLOR_PROGRAMGUIDETIMEBACK_15TO17_1,
< 		COLOR_PROGRAMGUIDETIMEBACK_15TO17_2,
< 		COLOR_PROGRAMGUIDETIMEBACK_18TO20_1,
< 		COLOR_PROGRAMGUIDETIMEBACK_18TO20_2,
< 		COLOR_PROGRAMGUIDETIMEBACK_21TO23_1,
< 		COLOR_PROGRAMGUIDETIMEBACK_21TO23_2,
< 		COLOR_PROGRAMGUIDETIMETEXT,
< 		COLOR_PROGRAMGUIDETIMELINE,
< 		COLOR_PROGRAMGUIDECURTIMELINE,
< 		COLOR_PROGRAMGUIDE_CONTENT_NEWS,
< 		COLOR_PROGRAMGUIDE_CONTENT_SPORTS,
< 		COLOR_PROGRAMGUIDE_CONTENT_INFORMATION,
< 		COLOR_PROGRAMGUIDE_CONTENT_DRAMA,
< 		COLOR_PROGRAMGUIDE_CONTENT_MUSIC,
< 		COLOR_PROGRAMGUIDE_CONTENT_VARIETY,
< 		COLOR_PROGRAMGUIDE_CONTENT_MOVIE,
< 		COLOR_PROGRAMGUIDE_CONTENT_ANIME,
< 		COLOR_PROGRAMGUIDE_CONTENT_DOCUMENTARY,
< 		COLOR_PROGRAMGUIDE_CONTENT_THEATER,
< 		COLOR_PROGRAMGUIDE_CONTENT_EDUCATION,
< 		COLOR_PROGRAMGUIDE_CONTENT_WELFARE,
< 		COLOR_PROGRAMGUIDE_CONTENT_OTHER,
< 		COLOR_PROGRAMGUIDE_CONTENT_FIRST=COLOR_PROGRAMGUIDE_CONTENT_NEWS,
< 		COLOR_PROGRAMGUIDE_CONTENT_LAST=COLOR_PROGRAMGUIDE_CONTENT_OTHER,
< 		COLOR_LAST=COLOR_PROGRAMGUIDE_CONTENT_LAST,
---
> 		COLOR_LAST=COLOR_SCREENBORDER,
184,217d33
< 		GRADIENT_PANELTABBACK,
< 		GRADIENT_PANELCURTABBACK,
< 		GRADIENT_PANELTABMARGIN,
< 		GRADIENT_PANELTITLEBACK,
< 		GRADIENT_PROGRAMLISTPANEL_EVENTBACK,
< 		GRADIENT_PROGRAMLISTPANEL_CUREVENTBACK,
< 		GRADIENT_PROGRAMLISTPANEL_TITLEBACK,
< 		GRADIENT_PROGRAMLISTPANEL_CURTITLEBACK,
< 		GRADIENT_CHANNELPANEL_CHANNELNAMEBACK,
< 		GRADIENT_CHANNELPANEL_CURCHANNELNAMEBACK,
< 		GRADIENT_CHANNELPANEL_EVENTNAMEBACK1,
< 		GRADIENT_CHANNELPANEL_EVENTNAMEBACK2,
< 		GRADIENT_CHANNELPANEL_CUREVENTNAMEBACK1,
< 		GRADIENT_CHANNELPANEL_CUREVENTNAMEBACK2,
< 		GRADIENT_CONTROLPANELBACK,
< 		GRADIENT_CONTROLPANELHIGHLIGHTBACK,
< 		GRADIENT_TITLEBARBACK,
< 		GRADIENT_TITLEBARICON,
< 		GRADIENT_TITLEBARHIGHLIGHTBACK,
< 		GRADIENT_SIDEBARBACK,
< 		GRADIENT_SIDEBARHIGHLIGHTBACK,
< 		GRADIENT_SIDEBARCHECKBACK,
< 		GRADIENT_NOTIFICATIONBARBACK,
< 		GRADIENT_PROGRAMGUIDECHANNELBACK,
< 		GRADIENT_PROGRAMGUIDECURCHANNELBACK,
< 		GRADIENT_PROGRAMGUIDETIMEBACK,
< 		GRADIENT_PROGRAMGUIDETIME0TO2BACK,
< 		GRADIENT_PROGRAMGUIDETIME3TO5BACK,
< 		GRADIENT_PROGRAMGUIDETIME6TO8BACK,
< 		GRADIENT_PROGRAMGUIDETIME9TO11BACK,
< 		GRADIENT_PROGRAMGUIDETIME12TO14BACK,
< 		GRADIENT_PROGRAMGUIDETIME15TO17BACK,
< 		GRADIENT_PROGRAMGUIDETIME18TO20BACK,
< 		GRADIENT_PROGRAMGUIDETIME21TO23BACK,
226,250d41
< 		BORDER_TITLEBAR,
< 		BORDER_TITLEBARCAPTION,
< 		BORDER_TITLEBARICON,
< 		BORDER_TITLEBARHIGHLIGHT,
< 		BORDER_SIDEBAR,
< 		BORDER_SIDEBARITEM,
< 		BORDER_SIDEBARHIGHLIGHT,
< 		BORDER_SIDEBARCHECK,
< 		BORDER_PROGRAMGUIDESTATUS,
< 		BORDER_PANEL_TAB,
< 		BORDER_PANEL_CURTAB,
< 		BORDER_PANEL_TABMARGIN,
< 		BORDER_PANEL_TITLE,
< 		BORDER_PROGRAMLISTPANEL_EVENT,
< 		BORDER_PROGRAMLISTPANEL_CUREVENT,
< 		BORDER_PROGRAMLISTPANEL_TITLE,
< 		BORDER_PROGRAMLISTPANEL_CURTITLE,
< 		BORDER_CHANNELPANEL_CHANNELNAME,
< 		BORDER_CHANNELPANEL_CURCHANNELNAME,
< 		BORDER_CHANNELPANEL_EVENTNAME1,
< 		BORDER_CHANNELPANEL_EVENTNAME2,
< 		BORDER_CHANNELPANEL_CUREVENTNAME1,
< 		BORDER_CHANNELPANEL_CUREVENTNAME2,
< 		BORDER_CONTROLPANELITEM,
< 		BORDER_CONTROLPANELHIGHLIGHTITEM,
257,278d47
< 		STYLE_TITLEBARCAPTION,
< 		STYLE_TITLEBARICON,
< 		STYLE_TITLEBARHIGHLIGHTITEM,
< 		STYLE_SIDEBARITEM,
< 		STYLE_SIDEBARHIGHLIGHTITEM,
< 		STYLE_SIDEBARCHECKITEM,
< 		STYLE_PANEL_TAB,
< 		STYLE_PANEL_CURTAB,
< 		STYLE_PANEL_TABMARGIN,
< 		STYLE_PANEL_TITLE,
< 		STYLE_PROGRAMLISTPANEL_EVENT,
< 		STYLE_PROGRAMLISTPANEL_CUREVENT,
< 		STYLE_PROGRAMLISTPANEL_TITLE,
< 		STYLE_PROGRAMLISTPANEL_CURTITLE,
< 		STYLE_CHANNELPANEL_CHANNELNAME,
< 		STYLE_CHANNELPANEL_CURCHANNELNAME,
< 		STYLE_CHANNELPANEL_EVENTNAME1,
< 		STYLE_CHANNELPANEL_EVENTNAME2,
< 		STYLE_CHANNELPANEL_CURCHANNELEVENTNAME1,
< 		STYLE_CHANNELPANEL_CURCHANNELEVENTNAME2,
< 		STYLE_CONTROLPANELITEM,
< 		STYLE_CONTROLPANELHIGHLIGHTITEM,
302c71
< 	LPCTSTR GetName() const { return m_Name.Get(); }
---
> 	LPCTSTR GetName() const { return m_Name.c_str(); }
304,306c73
< 	LPCTSTR GetFileName() const { return m_FileName.Get(); }
< 	bool Load(CSettings &Settings);
< 	bool Save(CSettings &Settings) const;
---
> 	LPCTSTR GetFileName() const { return m_FileName.c_str(); }
308d74
< 	bool Save(LPCTSTR pszFileName) const;
328,329c94,95
< 	CDynamicString m_Name;
< 	CDynamicString m_FileName;
---
> 	std::basic_string<TCHAR> m_Name;
> 	std::basic_string<TCHAR> m_FileName;
361,420d126
< 
< class CColorSchemeList
< {
< public:
< 	CColorSchemeList();
< 	~CColorSchemeList();
< 	int NumColorSchemes() const { return (int)m_List.size(); }
< 	bool Add(CColorScheme *pColorScheme);
< 	bool Insert(int Index,CColorScheme *pColorScheme);
< 	bool Load(LPCTSTR pszDirectory);
< 	void Clear();
< 	CColorScheme *GetColorScheme(int Index);
< 	bool SetColorScheme(int Index,const CColorScheme *pColorScheme);
< 	int FindByName(LPCTSTR pszName,int FirstIndex=0) const;
< 	void SortByName();
< 
< private:
< 	std::vector<CColorScheme*> m_List;
< };
< 
< class CColorSchemeOptions : public COptions
< {
< public:
< 	typedef bool (*ApplyFunc)(const CColorScheme *pColorScheme);
< 
< 	CColorSchemeOptions();
< 	~CColorSchemeOptions();
< // COptions
< 	bool LoadSettings(CSettings &Settings) override;
< 	bool SaveSettings(CSettings &Settings) override;
< // CBasicDialog
< 	bool Create(HWND hwndOwner) override;
< // CColorSchemeOptions
< 	bool SetApplyCallback(ApplyFunc pCallback);
< 	bool ApplyColorScheme() const;
< 	const CColorScheme *GetColorScheme() const { return m_pColorScheme; }
< 	COLORREF GetColor(int Type) const;
< 	COLORREF GetColor(LPCTSTR pszText) const;
< 	static bool GetThemesDirectory(LPTSTR pszDirectory,int MaxLength,bool fCreate=false);
< 
< private:
< 	CColorScheme *m_pColorScheme;
< 	CColorSchemeList m_PresetList;
< 	CColorScheme::GradientStyle m_GradientList[CColorScheme::NUM_GRADIENTS];
< 	Theme::BorderType m_BorderList[CColorScheme::NUM_BORDERS];
< 	CColorScheme *m_pPreviewColorScheme;
< 	bool m_fPreview;
< 	ApplyFunc m_pApplyFunc;
< 	CColorPalette m_ColorPalette;
< 
< // CBasicDialog
< 	INT_PTR DlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam) override;
< 
< 	bool Apply(const CColorScheme *pColorScheme) const;
< 	void GetCurrentSettings(CColorScheme *pColorScheme);
< 	static const LPCTSTR m_pszExtension;
< 
< 	static INT_PTR CALLBACK SaveDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
< };
< 
diff TVTestStatusView_orig/DrawUtil.cpp ./DrawUtil.cpp
1c1,2
< #include "stdafx.h"
---
> #include <Windows.h>
> #include <CommCtrl.h>
258,437d258
< // 光沢を描画する
< bool GlossOverlay(HDC hdc,const RECT *pRect,
< 				  int Highlight1,int Highlight2,int Shadow1,int Shadow2)
< {
< 	const int Width=pRect->right-pRect->left;
< 	const int Height=pRect->bottom-pRect->top;
< 	if (Width<=0 || Height<=0)
< 		return false;
< 
< 	BITMAPINFO bmi;
< 	::ZeroMemory(&bmi,sizeof(bmi));
< 	bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
< 	bmi.bmiHeader.biWidth=Width;
< 	bmi.bmiHeader.biHeight=-Height;
< 	bmi.bmiHeader.biPlanes=1;
< 	bmi.bmiHeader.biBitCount=32;
< 	void *pBits;
< 	HBITMAP hbm=::CreateDIBSection(NULL,&bmi,DIB_RGB_COLORS,&pBits,NULL,0);
< 	if (hbm==NULL)
< 		return false;
< 
< 	const SIZE_T RowBytes=Width*4;
< 	const int Center=Height/2;
< 	int x,y;
< 	BYTE *p=static_cast<BYTE*>(pBits);
< 	for (y=0;y<Center;y++) {
< 		::FillMemory(p,RowBytes,
< 					 (BYTE)(((y*Highlight2)+(Center-1-y)*Highlight1)/(Center-1)));
< 		p+=RowBytes;
< 	}
< 	for (;y<Height;y++) {
< 		BYTE Alpha=(BYTE)(((y-Center)*Shadow2+(Height-1-y)*Shadow1)/(Height-Center-1));
< 		::ZeroMemory(p,RowBytes);
< 		for (x=0;x<Width;x++) {
< 			p[x*4+3]=Alpha;
< 		}
< 		p+=RowBytes;
< 	}
< 
< 	HDC hdcMemory=::CreateCompatibleDC(hdc);
< 	if (hdcMemory==NULL) {
< 		::DeleteObject(hbm);
< 		return false;
< 	}
< 	HBITMAP hbmOld=SelectBitmap(hdcMemory,hbm);
< 	BLENDFUNCTION bf={AC_SRC_OVER,0,255,AC_SRC_ALPHA};
< 	::GdiAlphaBlend(hdc,pRect->left,pRect->top,Width,Height,
< 					hdcMemory,0,0,Width,Height,bf);
< 	::SelectObject(hdcMemory,hbmOld);
< 	::DeleteDC(hdcMemory);
< 	::DeleteObject(hbm);
< 	return true;
< }
< 
< 
< // 単色を合成する
< bool ColorOverlay(HDC hdc,const RECT *pRect,COLORREF Color,BYTE Opacity)
< {
< 	const int Width=pRect->right-pRect->left;
< 	const int Height=pRect->bottom-pRect->top;
< 	if (Width<=0 || Height<=0)
< 		return false;
< 
< 	BITMAPINFO bmi;
< 	::ZeroMemory(&bmi,sizeof(bmi));
< 	bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
< 	bmi.bmiHeader.biWidth=Width;
< 	bmi.bmiHeader.biHeight=-Height;
< 	bmi.bmiHeader.biPlanes=1;
< 	bmi.bmiHeader.biBitCount=32;
< 	void *pBits;
< 	HBITMAP hbm=::CreateDIBSection(NULL,&bmi,DIB_RGB_COLORS,&pBits,NULL,0);
< 	if (hbm==NULL)
< 		return false;
< 
< 	const DWORD Pixel=0xFF000000|((DWORD)GetRValue(Color)<<16)|((DWORD)GetGValue(Color)<<8)|(DWORD)GetBValue(Color);
< 	DWORD *p=static_cast<DWORD*>(pBits);
< 	DWORD *pEnd=p+Width*Height;
< 	do {
< 		*p++=Pixel;
< 	} while (p<pEnd);
< 
< 	HDC hdcMemory=::CreateCompatibleDC(hdc);
< 	if (hdcMemory==NULL) {
< 		::DeleteObject(hbm);
< 		return false;
< 	}
< 	HBITMAP hbmOld=SelectBitmap(hdcMemory,hbm);
< 	BLENDFUNCTION bf={AC_SRC_OVER,0,Opacity,0};
< 	::GdiAlphaBlend(hdc,pRect->left,pRect->top,Width,Height,
< 					hdcMemory,0,0,Width,Height,bf);
< 	::SelectObject(hdcMemory,hbmOld);
< 	::DeleteDC(hdcMemory);
< 	::DeleteObject(hbm);
< 	return true;
< }
< 
< 
< // 指定された矩形の周囲を塗りつぶす
< bool FillBorder(HDC hdc,const RECT *pBorderRect,const RECT *pEmptyRect,const RECT *pPaintRect,HBRUSH hbr)
< {
< 	RECT rc;
< 
< 	if (pPaintRect->left<pBorderRect->right && pPaintRect->right>pBorderRect->left) {
< 		rc.left=max(pPaintRect->left,pBorderRect->left);
< 		rc.right=min(pPaintRect->right,pBorderRect->right);
< 		rc.top=max(pPaintRect->top,pBorderRect->top);
< 		rc.bottom=min(pPaintRect->bottom,pEmptyRect->top);
< 		if (rc.top<rc.bottom)
< 			::FillRect(hdc,&rc,hbr);
< 		rc.top=max(pEmptyRect->bottom,pPaintRect->top);
< 		rc.bottom=min(pPaintRect->bottom,pBorderRect->bottom);
< 		if (rc.top<rc.bottom)
< 			::FillRect(hdc,&rc,hbr);
< 	}
< 	if (pPaintRect->top<pEmptyRect->bottom && pPaintRect->bottom>pEmptyRect->top) {
< 		rc.top=max(pEmptyRect->top,pPaintRect->top);
< 		rc.bottom=min(pEmptyRect->bottom,pPaintRect->bottom);
< 		rc.left=max(pPaintRect->left,pBorderRect->left);
< 		rc.right=min(pEmptyRect->left,pPaintRect->right);
< 		if (rc.left<rc.right)
< 			::FillRect(hdc,&rc,hbr);
< 		rc.left=max(pPaintRect->left,pEmptyRect->right);
< 		rc.right=min(pPaintRect->right,pBorderRect->right);
< 		if (rc.left<rc.right)
< 			::FillRect(hdc,&rc,hbr);
< 	}
< 	return true;
< }
< 
< 
< // ビットマップを描画する
< bool DrawBitmap(HDC hdc,int DstX,int DstY,int DstWidth,int DstHeight,
< 				HBITMAP hbm,const RECT *pSrcRect,BYTE Opacity)
< {
< 	if (hdc==NULL || hbm==NULL)
< 		return false;
< 
< 	int SrcX,SrcY,SrcWidth,SrcHeight;
< 	if (pSrcRect!=NULL) {
< 		SrcX=pSrcRect->left;
< 		SrcY=pSrcRect->top;
< 		SrcWidth=pSrcRect->right-pSrcRect->left;
< 		SrcHeight=pSrcRect->bottom-pSrcRect->top;
< 	} else {
< 		BITMAP bm;
< 		if (::GetObject(hbm,sizeof(BITMAP),&bm)!=sizeof(BITMAP))
< 			return false;
< 		SrcX=SrcY=0;
< 		SrcWidth=bm.bmWidth;
< 		SrcHeight=bm.bmHeight;
< 	}
< 
< 	HDC hdcMemory=::CreateCompatibleDC(hdc);
< 	if (hdcMemory==NULL)
< 		return false;
< 	HBITMAP hbmOld=static_cast<HBITMAP>(::SelectObject(hdcMemory,hbm));
< 
< 	if (Opacity==255) {
< 		if (SrcWidth==DstWidth && SrcHeight==DstHeight) {
< 			::BitBlt(hdc,DstX,DstY,DstWidth,DstHeight,
< 					 hdcMemory,SrcX,SrcY,SRCCOPY);
< 		} else {
< 			int OldStretchMode=::SetStretchBltMode(hdc,STRETCH_HALFTONE);
< 			::StretchBlt(hdc,DstX,DstY,DstWidth,DstHeight,
< 						 hdcMemory,SrcX,SrcY,SrcWidth,SrcHeight,SRCCOPY);
< 			::SetStretchBltMode(hdc,OldStretchMode);
< 		}
< 	} else {
< 		BLENDFUNCTION bf={AC_SRC_OVER,0,Opacity,0};
< 		::GdiAlphaBlend(hdc,DstX,DstY,DstWidth,DstHeight,
< 						hdcMemory,SrcX,SrcY,SrcWidth,SrcHeight,bf);
< 	}
< 
< 	::SelectObject(hdcMemory,hbmOld);
< 	::DeleteDC(hdcMemory);
< 	return true;
< }
< 
< 
507,648d327
< HBITMAP ResizeBitmap(HBITMAP hbmSrc,int Width,int Height,int BitCount,int StretchMode)
< {
< 	if (hbmSrc==NULL || Width<1 || Height==0)
< 		return NULL;
< 
< 	HBITMAP hbm=CreateDIB(Width,Height,BitCount);
< 	if (hbm==NULL)
< 		return NULL;
< 
< 	bool fOK=false;
< 	HDC hdcSrc=::CreateCompatibleDC(NULL);
< 	HDC hdcDst=::CreateCompatibleDC(NULL);
< 	if (hdcSrc!=NULL && hdcDst!=NULL) {
< 		HBITMAP hbmSrcOld=SelectBitmap(hdcSrc,hbmSrc);
< 		HBITMAP hbmDstOld=SelectBitmap(hdcDst,hbm);
< 		int OldStretchMode=::SetStretchBltMode(hdcDst,StretchMode);
< 		BITMAP bm;
< 		::GetObject(hbmSrc,sizeof(bm),&bm);
< 		::StretchBlt(hdcDst,0,0,Width,abs(Height),
< 					 hdcSrc,0,0,bm.bmWidth,bm.bmHeight,SRCCOPY);
< 		::SetStretchBltMode(hdcDst,OldStretchMode);
< 		::SelectObject(hdcDst,hbmDstOld);
< 		::SelectObject(hdcSrc,hbmSrcOld);
< 		fOK=true;
< 	}
< 	if (hdcDst!=NULL)
< 		::DeleteDC(hdcDst);
< 	if (hdcSrc!=NULL)
< 		::DeleteDC(hdcSrc);
< 
< 	if (!fOK) {
< 		::DeleteObject(hbm);
< 		return NULL;
< 	}
< 
< 	return hbm;
< }
< 
< 
< // テキストを描画する
< bool DrawText(HDC hdc,LPCTSTR pszText,const RECT &Rect,UINT Format,
< 			  const CFont *pFont,COLORREF Color)
< {
< 	if (hdc==NULL || pszText==NULL)
< 		return false;
< 
< 	int OldBkMode;
< 	COLORREF OldTextColor;
< 	HFONT hfontOld;
< 
< 	OldBkMode=::SetBkMode(hdc,TRANSPARENT);
< 	if (Color!=CLR_INVALID)
< 		OldTextColor=::SetTextColor(hdc,Color);
< 	if (pFont!=NULL)
< 		hfontOld=DrawUtil::SelectObject(hdc,*pFont);
< 	RECT rc=Rect;
< 	::DrawText(hdc,pszText,-1,&rc,Format);
< 	if (pFont!=NULL)
< 		::SelectObject(hdc,hfontOld);
< 	if (Color!=CLR_INVALID)
< 		::SetTextColor(hdc,OldTextColor);
< 	::SetBkMode(hdc,OldBkMode);
< 	return true;
< }
< 
< 
< // テキストを指定幅で折り返して何行になるか計算する
< int CalcWrapTextLines(HDC hdc,LPCTSTR pszText,int Width)
< {
< 	if (hdc==NULL || pszText==NULL)
< 		return 0;
< 
< 	LPCTSTR p;
< 	int Length;
< 	int Fit;
< 	SIZE sz;
< 	int Lines=0;
< 
< 	p=pszText;
< 	while (*p!=_T('\0')) {
< 		if (*p==_T('\r') || *p==_T('\n')) {
< 			p++;
< 			if (*p==_T('\n'))
< 				p++;
< 			if (*p==_T('\0'))
< 				break;
< 			Lines++;
< 			continue;
< 		}
< 		for (Length=0;p[Length]!=_T('\0') && p[Length]!=_T('\r') && p[Length]!=_T('\n');Length++);
< 		::GetTextExtentExPoint(hdc,p,Length,Width,&Fit,NULL,&sz);
< 		if (Fit<1)
< 			Fit=1;
< 		p+=Fit;
< 		Lines++;
< 		if (*p==_T('\r'))
< 			p++;
< 		if (*p==_T('\n'))
< 			p++;
< 	}
< 	return Lines;
< }
< 
< 
< // テキストを指定幅で折り返して描画する
< bool DrawWrapText(HDC hdc,LPCTSTR pszText,const RECT *pRect,int LineHeight)
< {
< 	if (hdc==NULL || pszText==NULL || pRect==NULL)
< 		return false;
< 
< 	LPCTSTR p;
< 	int y;
< 	int Length;
< 	int Fit;
< 	SIZE sz;
< 
< 	p=pszText;
< 	y=pRect->top;
< 	while (*p!=_T('\0') && y<pRect->bottom) {
< 		if (*p==_T('\r') || *p==_T('\n')) {
< 			p++;
< 			if (*p==_T('\n'))
< 				p++;
< 			y+=LineHeight;
< 			continue;
< 		}
< 		for (Length=0;p[Length]!=_T('\0') && p[Length]!=_T('\r') && p[Length]!=_T('\n');Length++);
< 		::GetTextExtentExPoint(hdc,p,Length,pRect->right-pRect->left,&Fit,NULL,&sz);
< 		if (Fit<1)
< 			Fit=1;
< 		::TextOut(hdc,pRect->left,y,p,Fit);
< 		p+=Fit;
< 		y+=LineHeight;
< 		if (*p==_T('\r'))
< 			p++;
< 		if (*p==_T('\n'))
< 			p++;
< 	}
< 	return true;
< }
< 
< 
676,746d354
< // UIに使用するデフォルトのフォントを取得する
< bool GetDefaultUIFont(LOGFONT *pFont)
< {
< 	if (pFont==NULL)
< 		return false;
< 
< 	::ZeroMemory(pFont,sizeof(LOGFONT));
< 
< 	LOGFONT MessageFont;
< 	if (GetSystemFont(FONT_MESSAGE,&MessageFont)) {
< 		// メイリオだと行間が空きすぎるのが…
< 		if (::lstrcmp(MessageFont.lfFaceName,TEXT("メイリオ"))==0
< 				|| ::lstrcmpi(MessageFont.lfFaceName,TEXT("Meiryo"))==0) {
< 			//pFont->lfHeight=MessageFont.lfHeight;
< 			pFont->lfHeight=-12;
< 			pFont->lfWeight=FW_NORMAL;
< 			::lstrcpy(pFont->lfFaceName,TEXT("Meiryo UI"));
< 			if (IsFontAvailable(*pFont))
< 				return true;
< 		} else {
< 			*pFont=MessageFont;
< 			return true;
< 		}
< 	}
< 
< 	return GetSystemFont(FONT_DEFAULT,pFont);
< }
< 
< 
< bool IsFontAvailable(const LOGFONT &Font,HDC hdc)
< {
< 	HFONT hfont=::CreateFontIndirect(&Font);
< 
< 	if (hfont==NULL)
< 		return false;
< 	HDC hdcMem=NULL;
< 	if (hdc==NULL) {
< 		hdcMem=::CreateCompatibleDC(NULL);
< 		if (hdcMem==NULL)
< 			return false;
< 		hdc=hdcMem;
< 	}
< 	HFONT hfontOld=SelectFont(hdc,hfont);
< 	TCHAR szFaceName[LF_FACESIZE];
< 	bool fAvailable=
< 		::GetTextFace(hdc,_countof(szFaceName),szFaceName)>0
< 		&& ::lstrcmpi(szFaceName,Font.lfFaceName)==0;
< 	::SelectObject(hdc,hfontOld);
< 	if (hdcMem!=NULL)
< 		::DeleteDC(hdcMem);
< 
< 	return fAvailable;
< }
< 
< 
< bool IsFontSmoothingEnabled()
< {
< 	BOOL fEnabled=FALSE;
< 	return ::SystemParametersInfo(SPI_GETFONTSMOOTHING,0,&fEnabled,0) && fEnabled;
< }
< 
< 
< bool IsClearTypeEnabled()
< {
< 	UINT Type;
< 	return IsFontSmoothingEnabled()
< 		&& ::SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE,0,&Type,0)
< 		&& Type==FE_FONTSMOOTHINGCLEARTYPE;
< }
< 
< 
876,931d483
< CBrush::CBrush()
< 	: m_hbr(NULL)
< {
< }
< 
< CBrush::CBrush(const CBrush &Brush)
< 	: m_hbr(NULL)
< {
< 	*this=Brush;
< }
< 
< CBrush::CBrush(COLORREF Color)
< 	: m_hbr(NULL)
< {
< 	Create(Color);
< }
< 
< CBrush::~CBrush()
< {
< 	Destroy();
< }
< 
< CBrush &CBrush::operator=(const CBrush &Brush)
< {
< 	if (&Brush!=this) {
< 		Destroy();
< 		if (Brush.m_hbr!=NULL) {
< 			LOGBRUSH lb;
< 
< 			if (::GetObject(Brush.m_hbr,sizeof(LOGBRUSH),&lb)==sizeof(LOGBRUSH))
< 				m_hbr=::CreateBrushIndirect(&lb);
< 		}
< 	}
< 	return *this;
< }
< 
< bool CBrush::Create(COLORREF Color)
< {
< 	HBRUSH hbr=::CreateSolidBrush(Color);
< 
< 	if (hbr==NULL)
< 		return false;
< 	Destroy();
< 	m_hbr=hbr;
< 	return true;
< }
< 
< void CBrush::Destroy()
< {
< 	if (m_hbr!=NULL) {
< 		::DeleteObject(m_hbr);
< 		m_hbr=NULL;
< 	}
< }
< 
< 
1021,1022c573,578
< CMonoColorBitmap::CMonoColorBitmap()
< 	: m_hbm(NULL)
---
> COffscreen::COffscreen()
> 	: m_hdc(NULL)
> 	, m_hbm(NULL)
> 	, m_hbmOld(NULL)
> 	, m_Width(0)
> 	, m_Height(0)
1026c582
< CMonoColorBitmap::~CMonoColorBitmap()
---
> COffscreen::~COffscreen()
1031c587
< bool CMonoColorBitmap::Load(HINSTANCE hinst,LPCTSTR pszName)
---
> bool COffscreen::Create(int Width,int Height,HDC hdc)
1033,1034c589
< 	HBITMAP hbmSrc=static_cast<HBITMAP>(::LoadImage(hinst,pszName,IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION));
< 	if (hbmSrc==NULL)
---
> 	if (Width<=0 || Height<=0)
1036,1045d590
< 
< 	bool fResult=Create(hbmSrc);
< 
< 	::DeleteObject(hbmSrc);
< 
< 	return fResult;
< }
< 
< bool CMonoColorBitmap::Create(HBITMAP hbmSrc)
< {
1047,1054c592,604
< 
< 	if (hbmSrc==NULL)
< 		return false;
< 
< 	BITMAP bm;
< 	::GetObject(hbmSrc,sizeof(bm),&bm);
< 	if ((bm.bmBitsPixel!=8 && bm.bmBitsPixel!=24 && bm.bmBitsPixel!=32)
< 			|| bm.bmBits==NULL)
---
> 	HDC hdcScreen;
> 	if (hdc==NULL) {
> 		hdcScreen=::GetDC(NULL);
> 		if (hdcScreen==NULL)
> 			return false;
> 		hdc=hdcScreen;
> 	} else {
> 		hdcScreen=NULL;
> 	}
> 	m_hdc=::CreateCompatibleDC(hdc);
> 	if (m_hdc==NULL) {
> 		if (hdcScreen!=NULL)
> 			::ReleaseDC(NULL,hdcScreen);
1056,1059c606,611
< 
< 	void *pBits;
< 	m_hbm=CreateDIB(bm.bmWidth,bm.bmHeight,32,&pBits);
< 	if (m_hbm==NULL)
---
> 	}
> 	m_hbm=::CreateCompatibleBitmap(hdc,Width,Height);
> 	if (hdcScreen!=NULL)
> 		::ReleaseDC(NULL,hdcScreen);
> 	if (m_hbm==NULL) {
> 		Destroy();
1061,1082d612
< 
< 	if (bm.bmBitsPixel==32) {
< 		::CopyMemory(pBits,bm.bmBits,bm.bmWidth*4*bm.bmHeight);
< 		m_fColorImage=true;
< 	} else {
< 		BYTE *p=static_cast<BYTE*>(bm.bmBits);
< 		BYTE *q=static_cast<BYTE*>(pBits);
< 		for (int y=0;y<bm.bmHeight;y++) {
< 			if (bm.bmBitsPixel==8) {
< 				for (int x=0;x<bm.bmWidth;x++) {
< 					q[3]=p[x];
< 					q+=4;
< 				}
< 			} else {
< 				for (int x=0;x<bm.bmWidth;x++) {
< 					q[3]=p[x*3];
< 					q+=4;
< 				}
< 			}
< 			p+=(bm.bmWidth*bm.bmBitsPixel+31)/32*4;
< 		}
< 		m_fColorImage=false;
1084,1086c614,616
< 
< 	m_Color=CLR_INVALID;
< 
---
> 	m_hbmOld=static_cast<HBITMAP>(::SelectObject(m_hdc,m_hbm));
> 	m_Width=Width;
> 	m_Height=Height;
1090c620
< void CMonoColorBitmap::Destroy()
---
> void COffscreen::Destroy()
1091a622,629
> 	if (m_hbmOld!=NULL) {
> 		::SelectObject(m_hdc,m_hbmOld);
> 		m_hbmOld=NULL;
> 	}
> 	if (m_hdc!=NULL) {
> 		::DeleteDC(m_hdc);
> 		m_hdc=NULL;
> 	}
1094a633,634
> 		m_Width=0;
> 		m_Height=0;
1098c638
< bool CMonoColorBitmap::Draw(HDC hdc,int DstX,int DstY,COLORREF Color,int SrcX,int SrcY,int Width,int Height)
---
> bool COffscreen::CopyTo(HDC hdc,const RECT *pDstRect)
1100,1115c640
< 	if (m_hbm==NULL)
< 		return false;
< 
< 	BITMAP bm;
< 	if (::GetObject(m_hbm,sizeof(bm),&bm)!=sizeof(bm))
< 		return false;
< 
< 	if (Width<=0)
< 		Width=bm.bmWidth;
< 	if (Height<=0)
< 		Height=bm.bmHeight;
< 	if (SrcX<0 || SrcY<0 || SrcX+Width>bm.bmWidth || SrcY+Height>bm.bmHeight)
< 		return false;
< 
< 	if (!m_fColorImage)
< 		SetColor(Color);
---
> 	int DstX,DstY,Width,Height;
1117,1317c642
< 	HDC hdcMemory=::CreateCompatibleDC(hdc);
< 	if (hdcMemory==NULL)
< 		return false;
< 	HBITMAP hbmOld=static_cast<HBITMAP>(::SelectObject(hdcMemory,m_hbm));
< 	BLENDFUNCTION bf={AC_SRC_OVER,0,255,AC_SRC_ALPHA};
< 	::GdiAlphaBlend(hdc,DstX,DstY,Width,Height,
< 					hdcMemory,SrcX,SrcY,Width,Height,bf);
< 	::SelectObject(hdcMemory,hbmOld);
< 	::DeleteDC(hdcMemory);
< 
< 	return true;
< }
< 
< HIMAGELIST CMonoColorBitmap::CreateImageList(int IconWidth,COLORREF Color)
< {
< 	if (m_hbm==NULL || IconWidth<1)
< 		return NULL;
< 
< 	BITMAP bm;
< 	if (::GetObject(m_hbm,sizeof(bm),&bm)!=sizeof(bm)
< 			|| bm.bmWidth<IconWidth)
< 		return NULL;
< 
< 	HIMAGELIST himl=::ImageList_Create(IconWidth,bm.bmHeight,ILC_COLOR32,0,1);
< 	if (himl==NULL)
< 		return NULL;
< 
< 	if (!m_fColorImage)
< 		SetColor(Color);
< 
< 	::ImageList_Add(himl,m_hbm,NULL);
< 
< 	return himl;
< }
< 
< void CMonoColorBitmap::SetColor(COLORREF Color)
< {
< 	if (m_Color!=Color) {
< 		BITMAP bm;
< 		if (::GetObject(m_hbm,sizeof(bm),&bm)!=sizeof(bm))
< 			return;
< 
< 		const UINT Red=GetRValue(Color),Green=GetGValue(Color),Blue=GetBValue(Color);
< 		BYTE *p=static_cast<BYTE*>(bm.bmBits);
< 		for (int y=0;y<bm.bmHeight;y++) {
< 			for (int x=0;x<bm.bmWidth;x++) {
< #define DIVIDE_BY_255(v) ((((v)+1)*257)>>16)
< 				UINT Alpha=p[3];
< 				p[0]=(BYTE)DIVIDE_BY_255(Blue*Alpha);
< 				p[1]=(BYTE)DIVIDE_BY_255(Green*Alpha);
< 				p[2]=(BYTE)DIVIDE_BY_255(Red*Alpha);
< 				p+=4;
< 			}
< 		}
< 		m_Color=Color;
< 	}
< }
< 
< 
< CMemoryDC::CMemoryDC()
< 	: m_hdc(NULL)
< {
< }
< 
< CMemoryDC::CMemoryDC(HDC hdc)
< 	: m_hdc(NULL)
< {
< 	Create(hdc);
< }
< 
< CMemoryDC::~CMemoryDC()
< {
< 	Delete();
< }
< 
< bool CMemoryDC::Create(HDC hdc)
< {
< 	Delete();
< 
< 	m_hdc=::CreateCompatibleDC(hdc);
< 	if (m_hdc==NULL)
< 		return false;
< 	m_hbmOld=static_cast<HBITMAP>(::GetCurrentObject(m_hdc,OBJ_BITMAP));
< 	return true;
< }
< 
< void CMemoryDC::Delete()
< {
< 	if (m_hdc!=NULL) {
< 		::SelectObject(m_hdc,m_hbmOld);
< 		::DeleteDC(m_hdc);
< 		m_hdc=NULL;
< 	}
< }
< 
< bool CMemoryDC::SetBitmap(HBITMAP hbm)
< {
< 	if (m_hdc==NULL || hbm==NULL)
< 		return false;
< 	::SelectObject(m_hdc,hbm);
< 	return true;
< }
< 
< bool CMemoryDC::Draw(HDC hdc,int DstX,int DstY,int SrcX,int SrcY,int Width,int Height)
< {
< 	if (m_hdc==NULL || hdc==NULL || Width<1 || Height<1)
< 		return false;
< 	return ::BitBlt(hdc,DstX,DstY,Width,Height,m_hdc,SrcX,SrcY,SRCCOPY)!=FALSE;
< }
< 
< bool CMemoryDC::DrawStretch(HDC hdc,int DstX,int DstY,int DstWidth,int DstHeight,
< 							int SrcX,int SrcY,int SrcWidth,int SrcHeight,int Mode)
< {
< 	if (m_hdc==NULL || hdc==NULL)
< 		return false;
< 	int OldStretchMode=::SetStretchBltMode(hdc,Mode);
< 	::StretchBlt(hdc,DstX,DstY,DstWidth,DstHeight,m_hdc,SrcX,SrcY,SrcWidth,SrcHeight,SRCCOPY);
< 	::SetStretchBltMode(hdc,OldStretchMode);
< 	return true;
< }
< 
< bool CMemoryDC::DrawAlpha(HDC hdc,int DstX,int DstY,int SrcX,int SrcY,int Width,int Height)
< {
< 	if (m_hdc==NULL || hdc==NULL)
< 		return false;
< 	BLENDFUNCTION bf={AC_SRC_OVER,0,255,AC_SRC_ALPHA};
< 	::GdiAlphaBlend(hdc,DstX,DstY,Width,Height,m_hdc,SrcX,SrcY,Width,Height,bf);
< 	return true;
< }
< 
< 
< COffscreen::COffscreen()
< 	: m_hdc(NULL)
< 	, m_hbm(NULL)
< 	, m_hbmOld(NULL)
< 	, m_Width(0)
< 	, m_Height(0)
< {
< }
< 
< COffscreen::~COffscreen()
< {
< 	Destroy();
< }
< 
< bool COffscreen::Create(int Width,int Height,HDC hdc)
< {
< 	if (Width<=0 || Height<=0)
< 		return false;
< 	Destroy();
< 	HDC hdcScreen;
< 	if (hdc==NULL) {
< 		hdcScreen=::GetDC(NULL);
< 		if (hdcScreen==NULL)
< 			return false;
< 		hdc=hdcScreen;
< 	} else {
< 		hdcScreen=NULL;
< 	}
< 	m_hdc=::CreateCompatibleDC(hdc);
< 	if (m_hdc==NULL) {
< 		if (hdcScreen!=NULL)
< 			::ReleaseDC(NULL,hdcScreen);
< 		return false;
< 	}
< 	m_hbm=::CreateCompatibleBitmap(hdc,Width,Height);
< 	if (hdcScreen!=NULL)
< 		::ReleaseDC(NULL,hdcScreen);
< 	if (m_hbm==NULL) {
< 		Destroy();
< 		return false;
< 	}
< 	m_hbmOld=static_cast<HBITMAP>(::SelectObject(m_hdc,m_hbm));
< 	m_Width=Width;
< 	m_Height=Height;
< 	return true;
< }
< 
< void COffscreen::Destroy()
< {
< 	if (m_hbmOld!=NULL) {
< 		::SelectObject(m_hdc,m_hbmOld);
< 		m_hbmOld=NULL;
< 	}
< 	if (m_hdc!=NULL) {
< 		::DeleteDC(m_hdc);
< 		m_hdc=NULL;
< 	}
< 	if (m_hbm!=NULL) {
< 		::DeleteObject(m_hbm);
< 		m_hbm=NULL;
< 		m_Width=0;
< 		m_Height=0;
< 	}
< }
< 
< bool COffscreen::CopyTo(HDC hdc,const RECT *pDstRect)
< {
< 	int DstX,DstY,Width,Height;
< 
< 	if (m_hdc==NULL || hdc==NULL)
---
> 	if (m_hdc==NULL || hdc==NULL)
1341,1873d665
< 
< 
< 
< 
< // GDI+のヘッダで整数型の引数にNULLを渡しているので
< // #define NULL nullptr するとエラーが出る…
< #if _MSC_VER >= 1600	// VC2010
< #undef NULL
< #define NULL 0
< #endif
< #include <gdiplus.h>
< 
< #pragma comment(lib, "gdiplus.lib")
< #ifdef WINDOWS2000_SUPPORT
< //#pragma comment(linker, "/DELAYLOAD:gdiplus.dll")
< #endif
< 
< 
< class CGdiPlusInitializer
< {
< 	bool m_fInitialized;
< 	ULONG_PTR m_Token;
< 
< public:
< 	CGdiPlusInitializer()
< 		: m_fInitialized(false)
< 	{
< 	}
< 
< 	~CGdiPlusInitializer()
< 	{
< 		Finalize();
< 	}
< 
< 	bool Initialize()
< 	{
< 		if (!m_fInitialized) {
< #ifdef WINDOWS2000_SUPPORT
< 			// GDI+ の DLL がロードできるか調べる
< 			// (gdiplus.dllが無くても起動するように遅延ロードの指定をしている)
< 			HMODULE hLib=::LoadLibrary(TEXT("gdiplus.dll"));
< 			if (hLib==NULL)
< 				return false;
< 			::FreeLibrary(hLib);
< #endif
< 
< 			Gdiplus::GdiplusStartupInput si;
< 			si.GdiplusVersion=1;
< 			si.DebugEventCallback=NULL;
< 			si.SuppressBackgroundThread=FALSE;
< 			si.SuppressExternalCodecs=FALSE;
< 			if (Gdiplus::GdiplusStartup(&m_Token,&si,NULL)!=Gdiplus::Ok)
< 				return false;
< 			m_fInitialized=true;
< 		}
< 		return true;
< 	}
< 
< 	void Finalize()
< 	{
< 		if (m_fInitialized) {
< 			Gdiplus::GdiplusShutdown(m_Token);
< 			m_fInitialized=false;
< 		}
< 	}
< };
< 
< static CGdiPlusInitializer GdiPlusInitializer;
< 
< 
< CGdiPlus::CGdiPlus()
< 	: m_fInitialized(false)
< {
< }
< 
< CGdiPlus::~CGdiPlus()
< {
< 	Finalize();
< }
< 
< bool CGdiPlus::Initialize()
< {
< 	if (!GdiPlusInitializer.Initialize())
< 		return false;
< 	m_fInitialized=true;
< 	return true;
< }
< 
< void CGdiPlus::Finalize()
< {
< 	m_fInitialized=false;
< }
< 
< bool CGdiPlus::DrawImage(CCanvas *pCanvas,CImage *pImage,int x,int y)
< {
< 	if (pCanvas!=NULL && pCanvas->m_pGraphics!=NULL
< 			 && pImage!=NULL && pImage->m_pBitmap!=NULL) {
< 		return pCanvas->m_pGraphics->DrawImage(pImage->m_pBitmap,x,y,
< 											   pImage->GetWidth(),
< 											   pImage->GetHeight())==Gdiplus::Ok;
< 	}
< 	return false;
< }
< 
< bool CGdiPlus::DrawImage(CCanvas *pCanvas,int DstX,int DstY,int DstWidth,int DstHeight,
< 	CImage *pImage,int SrcX,int SrcY,int SrcWidth,int SrcHeight,float Opacity)
< {
< 	if (pCanvas!=NULL && pCanvas->m_pGraphics!=NULL
< 			 && pImage!=NULL && pImage->m_pBitmap!=NULL) {
< 		Gdiplus::ImageAttributes Attributes;
< 		Gdiplus::ColorMatrix Matrix = {
< 			1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
< 			0.0f, 1.0f, 0.0f, 0.0f, 0.0f,
< 			0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
< 			0.0f, 0.0f, 0.0f, 1.0f, 0.0f,
< 			0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
<  		};
< 		Matrix.m[3][3]=Opacity;
< 		Attributes.SetColorMatrix(&Matrix);
< 		return pCanvas->m_pGraphics->DrawImage(pImage->m_pBitmap,
< 			Gdiplus::Rect(DstX,DstY,DstWidth,DstHeight),
< 			SrcX,SrcY,SrcWidth,SrcHeight,
< 			Gdiplus::UnitPixel,&Attributes)==Gdiplus::Ok;
< 	}
< 	return false;
< }
< 
< bool CGdiPlus::FillRect(CCanvas *pCanvas,CBrush *pBrush,const RECT *pRect)
< {
< 	if (pCanvas!=NULL && pCanvas->m_pGraphics!=NULL
< 			&& pBrush!=NULL && pBrush->m_pBrush!=NULL && pRect!=NULL) {
< 		return pCanvas->m_pGraphics->FillRectangle(pBrush->m_pBrush,
< 												   pRect->left,pRect->top,
< 												   pRect->right-pRect->left,
< 												   pRect->bottom-pRect->top)==Gdiplus::Ok;
< 	}
< 	return false;
< }
< 
< bool CGdiPlus::FillGradient(CCanvas *pCanvas,COLORREF Color1,COLORREF Color2,
< 							const RECT &Rect,GradientDirection Direction)
< {
< 	if (pCanvas!=NULL && pCanvas->m_pGraphics!=NULL) {
< 		Gdiplus::RectF rect(
< 			Gdiplus::REAL(Rect.left)-0.1f,
< 			Gdiplus::REAL(Rect.top)-0.1f,
< 			Gdiplus::REAL(Rect.right-Rect.left)+0.2f,
< 			Gdiplus::REAL(Rect.bottom-Rect.top)+0.2f);
< 		Gdiplus::LinearGradientBrush Brush(
< 			rect,
< 			Gdiplus::Color(GetRValue(Color1),GetGValue(Color1),GetBValue(Color1)),
< 			Gdiplus::Color(GetRValue(Color2),GetGValue(Color2),GetBValue(Color2)),
< 			Direction==GRADIENT_DIRECTION_HORZ?
< 				Gdiplus::LinearGradientModeHorizontal:
< 				Gdiplus::LinearGradientModeVertical);
< 		return pCanvas->m_pGraphics->FillRectangle(&Brush,rect)==Gdiplus::Ok;
< 	}
< 	return false;
< }
< 
< 
< CGdiPlus::CImage::CImage()
< 	: m_pBitmap(NULL)
< {
< }
< 
< CGdiPlus::CImage::CImage(const CImage &Src)
< 	: m_pBitmap(NULL)
< {
< 	*this=Src;
< }
< 
< CGdiPlus::CImage::~CImage()
< {
< 	Free();
< }
< 
< CGdiPlus::CImage &CGdiPlus::CImage::operator=(const CImage &Src)
< {
< 	if (&Src!=this) {
< 		Free();
< 		if (Src.m_pBitmap!=NULL)
< 			m_pBitmap=Src.m_pBitmap->Clone(0,0,Src.m_pBitmap->GetWidth(),Src.m_pBitmap->GetHeight(),Src.m_pBitmap->GetPixelFormat());
< 	}
< 	return *this;
< }
< 
< void CGdiPlus::CImage::Free()
< {
< 	if (m_pBitmap!=NULL) {
< 		delete m_pBitmap;
< 		m_pBitmap=NULL;
< 	}
< }
< 
< bool CGdiPlus::CImage::LoadFromFile(LPCWSTR pszFileName)
< {
< 	Free();
< 	m_pBitmap=Gdiplus::Bitmap::FromFile(pszFileName);
< 	return m_pBitmap!=NULL;
< }
< 
< bool CGdiPlus::CImage::LoadFromResource(HINSTANCE hinst,LPCWSTR pszName)
< {
< 	Free();
< 	m_pBitmap=Gdiplus::Bitmap::FromResource(hinst,pszName);
< 	return m_pBitmap!=NULL;
< }
< 
< bool CGdiPlus::CImage::LoadFromResource(HINSTANCE hinst,LPCTSTR pszName,LPCTSTR pszType)
< {
< 	Free();
< 
< 	HRSRC hRes=::FindResource(hinst,pszName,pszType);
< 	if (hRes==NULL)
< 		return false;
< 	DWORD Size=::SizeofResource(hinst,hRes);
< 	if (Size==0)
< 		return false;
< 	HGLOBAL hData=::LoadResource(hinst,hRes);
< 	const void *pData=::LockResource(hData);
< 	if (pData==NULL)
< 		return false;
< 	HGLOBAL hBuffer=::GlobalAlloc(GMEM_MOVEABLE,Size);
< 	if (hBuffer==NULL)
< 		return false;
< 	void *pBuffer=::GlobalLock(hBuffer);
< 	if (pBuffer==NULL) {
< 		::GlobalFree(hBuffer);
< 		return false;
< 	}
< 	::CopyMemory(pBuffer,pData,Size);
< 	::GlobalUnlock(hBuffer);
< 	IStream *pStream;
< 	if (::CreateStreamOnHGlobal(hBuffer,TRUE,&pStream)!=S_OK) {
< 		::GlobalFree(hBuffer);
< 		return false;
< 	}
< 	m_pBitmap=Gdiplus::Bitmap::FromStream(pStream);
< 	pStream->Release();
< 	return m_pBitmap!=NULL;
< }
< 
< bool CGdiPlus::CImage::Create(int Width,int Height,int BitsPerPixel)
< {
< 	Free();
< 	if (Width<=0 || Height<=0)
< 		return false;
< 	Gdiplus::PixelFormat Format;
< 	switch (BitsPerPixel) {
< 	case 1:		Format=PixelFormat1bppIndexed;	break;
< 	case 4:		Format=PixelFormat4bppIndexed;	break;
< 	case 8:		Format=PixelFormat8bppIndexed;	break;
< 	case 24:	Format=PixelFormat24bppRGB;	break;
< 	case 32:	Format=PixelFormat32bppARGB;	break;
< 	default:	return false;
< 	}
< 	m_pBitmap=new Gdiplus::Bitmap(Width,Height,Format);
< 	if (m_pBitmap==NULL)
< 		return false;
< 	Clear();
< 	return true;
< }
< 
< bool CGdiPlus::CImage::CreateFromBitmap(HBITMAP hbm,HPALETTE hpal)
< {
< 	Free();
< 	m_pBitmap=Gdiplus::Bitmap::FromHBITMAP(hbm,hpal);
< 	return m_pBitmap!=NULL;
< }
< 
< bool CGdiPlus::CImage::CreateFromDIB(const BITMAPINFO *pbmi,const void *pBits)
< {
< 	Free();
< 	m_pBitmap=new Gdiplus::Bitmap(pbmi,const_cast<void*>(pBits));
< 	return m_pBitmap!=NULL;
< }
< 
< bool CGdiPlus::CImage::IsCreated() const
< {
< 	return m_pBitmap!=NULL;
< }
< 
< int CGdiPlus::CImage::GetWidth() const
< {
< 	if (m_pBitmap==NULL)
< 		return 0;
< 	return m_pBitmap->GetWidth();
< }
< 
< int CGdiPlus::CImage::GetHeight() const
< {
< 	if (m_pBitmap==NULL)
< 		return 0;
< 	return m_pBitmap->GetHeight();
< }
< 
< void CGdiPlus::CImage::Clear()
< {
< 	if (m_pBitmap!=NULL) {
< 		Gdiplus::Rect rc(0,0,m_pBitmap->GetWidth(),m_pBitmap->GetHeight());
< 		Gdiplus::BitmapData Data;
< 
< 		if (m_pBitmap->LockBits(&rc,Gdiplus::ImageLockModeWrite,
< 								m_pBitmap->GetPixelFormat(),&Data)==Gdiplus::Ok) {
< 			BYTE *pBits=static_cast<BYTE*>(Data.Scan0);
< 			for (UINT y=0;y<Data.Height;y++) {
< 				::ZeroMemory(pBits,abs(Data.Stride));
< 				pBits+=Data.Stride;
< 			}
< 			m_pBitmap->UnlockBits(&Data);
< 		}
< 	}
< }
< 
< 
< CGdiPlus::CBrush::CBrush()
< 	: m_pBrush(NULL)
< {
< }
< 
< CGdiPlus::CBrush::CBrush(BYTE r,BYTE g,BYTE b,BYTE a)
< {
< 	m_pBrush=new Gdiplus::SolidBrush(Gdiplus::Color(a,r,g,b));
< }
< 
< CGdiPlus::CBrush::CBrush(COLORREF Color)
< {
< 	m_pBrush=new Gdiplus::SolidBrush(Gdiplus::Color(255,GetRValue(Color),GetGValue(Color),GetBValue(Color)));
< }
< 
< CGdiPlus::CBrush::~CBrush()
< {
< 	Free();
< }
< 
< void CGdiPlus::CBrush::Free()
< {
< 	if (m_pBrush!=NULL) {
< 		delete m_pBrush;
< 		m_pBrush=NULL;
< 	}
< }
< 
< bool CGdiPlus::CBrush::CreateSolidBrush(BYTE r,BYTE g,BYTE b,BYTE a)
< {
< 	Gdiplus::Color Color(a,r,g,b);
< 
< 	if (m_pBrush!=NULL) {
< 		m_pBrush->SetColor(Color);
< 	} else {
< 		m_pBrush=new Gdiplus::SolidBrush(Color);
< 		if (m_pBrush==NULL)
< 			return false;
< 	}
< 	return true;
< }
< 
< 
< CGdiPlus::CCanvas::CCanvas(HDC hdc)
< {
< 	m_pGraphics=new Gdiplus::Graphics(hdc);
< }
< 
< CGdiPlus::CCanvas::CCanvas(CImage *pImage)
< 	: m_pGraphics(NULL)
< {
< 	if (pImage!=NULL)
< 		m_pGraphics=new Gdiplus::Graphics(pImage->m_pBitmap);
< }
< 
< CGdiPlus::CCanvas::~CCanvas()
< {
< 	if (m_pGraphics!=NULL)
< 		delete m_pGraphics;
< }
< 
< bool CGdiPlus::CCanvas::Clear(BYTE r,BYTE g,BYTE b,BYTE a)
< {
< 	if (m_pGraphics==NULL)
< 		return false;
< 	return m_pGraphics->Clear(Gdiplus::Color(a,r,g,b))==Gdiplus::Ok;
< }
< 
< 
< 
< 
< #pragma comment(lib, "uxtheme.lib")
< #ifdef WINDOWS2000_SUPPORT
< //#pragma comment(linker, "/DELAYLOAD:uxtheme.dll")
< #endif
< 
< 
< CUxTheme::CUxTheme()
< 	: m_hTheme(NULL)
< #ifdef WINDOWS2000_SUPPORT
< 	, m_hLib(NULL)
< #endif
< {
< }
< 
< CUxTheme::~CUxTheme()
< {
< 	Close();
< #ifdef WINDOWS2000_SUPPORT
< 	if (m_hLib!=NULL)
< 		::FreeLibrary(m_hLib);
< #endif
< }
< 
< bool CUxTheme::Initialize()
< {
< #ifdef WINDOWS2000_SUPPORT
< 	if (m_hLib==NULL) {
< 		// uxtheme.dll がロードできるか調べる
< 		// (uxtheme.dllが無くても起動するように遅延ロードの指定をしている)
< 		m_hLib=::LoadLibrary(TEXT("uxtheme.dll"));
< 		if (m_hLib==NULL)
< 			return false;
< 	}
< #endif
< 	return true;
< }
< 
< bool CUxTheme::Open(HWND hwnd,LPCWSTR pszClassList)
< {
< 	Close();
< 	if (!Initialize())
< 		return false;
< 	m_hTheme=::OpenThemeData(hwnd,pszClassList);
< 	if (m_hTheme==NULL)
< 		return false;
< 	return true;
< }
< 
< void CUxTheme::Close()
< {
< 	if (m_hTheme!=NULL) {
< 		::CloseThemeData(m_hTheme);
< 		m_hTheme=NULL;
< 	}
< }
< 
< bool CUxTheme::IsOpen() const
< {
< 	return m_hTheme!=NULL;
< }
< 
< bool CUxTheme::IsActive()
< {
< #ifdef WINDOWS2000_SUPPORT
< 	if (m_hLib==NULL)
< 		return false;
< #endif
< 	return ::IsThemeActive()!=FALSE;
< }
< 
< bool CUxTheme::DrawBackground(HDC hdc,int PartID,int StateID,const RECT *pRect)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	return ::DrawThemeBackground(m_hTheme,hdc,PartID,StateID,pRect,NULL)==S_OK;
< }
< 
< bool CUxTheme::DrawBackground(HDC hdc,int PartID,int StateID,
< 							  int BackgroundPartID,int BackgroundStateID,
< 							  const RECT *pRect)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	if (::IsThemeBackgroundPartiallyTransparent(m_hTheme,PartID,StateID)) {
< 		if (::DrawThemeBackground(m_hTheme,hdc,
< 								  BackgroundPartID,BackgroundStateID,
< 								  pRect,NULL)!=S_OK)
< 			return false;
< 	}
< 	return ::DrawThemeBackground(m_hTheme,hdc,PartID,StateID,pRect,NULL)==S_OK;
< }
< 
< bool CUxTheme::DrawText(HDC hdc,int PartID,int StateID,LPCWSTR pszText,
< 						DWORD TextFlags,const RECT *pRect)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	return ::DrawThemeText(m_hTheme,hdc,PartID,StateID,pszText,lstrlenW(pszText),
< 						   TextFlags,0,pRect)==S_OK;
< }
< 
< bool CUxTheme::GetTextExtent(HDC hdc,int PartID,int StateID,LPCWSTR pszText,
< 							 DWORD TextFlags,RECT *pExtentRect)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	return ::GetThemeTextExtent(m_hTheme,hdc,PartID,StateID,
< 								pszText,lstrlenW(pszText),TextFlags,
< 								NULL,pExtentRect)==S_OK;
< }
< 
< bool CUxTheme::GetMargins(int PartID,int StateID,int PropID,MARGINS *pMargins)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	return ::GetThemeMargins(m_hTheme,NULL,PartID,StateID,PropID,NULL,pMargins)==S_OK;
< }
< 
< bool CUxTheme::GetColor(int PartID,int StateID,int PropID,COLORREF *pColor)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	return ::GetThemeColor(m_hTheme,PartID,StateID,PropID,pColor)==S_OK;
< }
< 
< bool CUxTheme::GetFont(int PartID,int StateID,int PropID,LOGFONT *pFont)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	return ::GetThemeFont(m_hTheme,NULL,PartID,StateID,PropID,pFont)==S_OK;
< }
< 
< bool CUxTheme::GetInt(int PartID,int StateID,int PropID,int *pValue)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	return ::GetThemeInt(m_hTheme,PartID,StateID,PropID,pValue)==S_OK;
< }
< 
< 
< bool CUxTheme::GetPartSize(HDC hdc,int PartID,int StateID,SIZE *pSize)
< {
< 	if (m_hTheme==NULL)
< 		return false;
< 	return ::GetThemePartSize(m_hTheme,hdc,PartID,StateID,NULL,TS_TRUE,pSize)==S_OK;
< }
diff TVTestStatusView_orig/DrawUtil.h ./DrawUtil.h
40,47d39
< bool GlossOverlay(HDC hdc,const RECT *pRect,
< 				  int Highlight1=192,int Highlight2=32,
< 				  int Shadow1=32,int Shadow2=0);
< bool ColorOverlay(HDC hdc,const RECT *pRect,COLORREF Color,BYTE Opacity=128);
< bool FillBorder(HDC hdc,const RECT *pBorderRect,const RECT *pEmptyRect,const RECT *pPaintRect,HBRUSH hbr);
< 
< bool DrawBitmap(HDC hdc,int DstX,int DstY,int DstWidth,int DstHeight,
< 				HBITMAP hbm,const RECT *pSrcRect=NULL,BYTE Opacity=255);
53,56d44
< HBITMAP ResizeBitmap(HBITMAP hbmSrc,int Width,int Height,int BitCount=24,int StretchMode=STRETCH_HALFTONE);
< 
< int CalcWrapTextLines(HDC hdc,LPCTSTR pszText,int Width);
< bool DrawWrapText(HDC hdc,LPCTSTR pszText,const RECT *pRect,int LineHeight);
68,71d55
< bool GetDefaultUIFont(LOGFONT *pFont);
< bool IsFontAvailable(const LOGFONT &Font,HDC hdc=NULL);
< bool IsFontSmoothingEnabled();
< bool IsClearTypeEnabled();
94,110d77
< bool DrawText(HDC hdc,LPCTSTR pszText,const RECT &Rect,UINT Format,
< 			  const CFont *pFont=NULL,COLORREF Color=CLR_INVALID);
< 
< class CBrush {
< 	HBRUSH m_hbr;
< public:
< 	CBrush();
< 	CBrush(const CBrush &Brush);
< 	CBrush(COLORREF Color);
< 	~CBrush();
< 	CBrush &operator=(const CBrush &Brush);
< 	bool Create(COLORREF Color);
< 	bool IsCreated() const { return m_hbr!=NULL; }
< 	void Destroy();
< 	HBRUSH GetHandle() const { return m_hbr; }
< };
< 
135,184d101
< inline HBRUSH SelectObject(HDC hdc,const CBrush &Brush) {
< 	return static_cast<HBRUSH>(::SelectObject(hdc,Brush.GetHandle()));
< }
< inline HBITMAP SelectObject(HDC hdc,const CBitmap &Bitmap) {
< 	return static_cast<HBITMAP>(::SelectObject(hdc,Bitmap.GetHandle()));
< }
< 
< class CMonoColorBitmap
< {
< public:
< 	CMonoColorBitmap();
< 	~CMonoColorBitmap();
< 	bool Load(HINSTANCE hinst,LPCTSTR pszName);
< 	bool Load(HINSTANCE hinst,int ID) { return Load(hinst,MAKEINTRESOURCE(ID)); }
< 	bool Create(HBITMAP hbm);
< 	void Destroy();
< 	HBITMAP GetHandle() const { return m_hbm; }
< 	bool IsCreated() const { return m_hbm!=NULL; }
< 	bool Draw(HDC hdc,int DstX,int DstY,COLORREF Color,int SrcX=0,int SrcY=0,int Width=0,int Height=0);
< 	HIMAGELIST CreateImageList(int IconWidth,COLORREF Color);
< 
< private:
< 	void SetColor(COLORREF Color);
< 
< 	HBITMAP m_hbm;
< 	COLORREF m_Color;
< 	bool m_fColorImage;
< };
< 
< class CMemoryDC
< {
< public:
< 	CMemoryDC();
< 	CMemoryDC(HDC hdc);
< 	~CMemoryDC();
< 	bool Create(HDC hdc=NULL);
< 	void Delete();
< 	bool IsCreated() const { return m_hdc!=NULL; }
< 	bool SetBitmap(HBITMAP hbmSrc);
< 	bool SetBitmap(CBitmap &Bitmap) { return SetBitmap(Bitmap.GetHandle()); }
< 	bool Draw(HDC hdc,int DstX,int DstY,int SrcX,int SrcY,int Width,int Height);
< 	bool DrawStretch(HDC hdc,int DstX,int DstY,int DstWidth,int DstHeight,
< 					 int SrcX,int SrcY,int SrcWidth,int SrcHeight,
< 					 int Mode=STRETCH_HALFTONE);
< 	bool DrawAlpha(HDC hdc,int DstX,int DstY,int SrcX,int SrcY,int Width,int Height);
< 
< private:
< 	HDC m_hdc;
< 	HBITMAP m_hbmOld;
< };
206,315d122
< 
< 
< namespace Gdiplus {
< class Graphics;
< class Bitmap;
< class SolidBrush;
< }
< 
< class CGdiPlus
< {
< public:
< 	class CImage {
< 		Gdiplus::Bitmap *m_pBitmap;
< 	public:
< 		CImage();
< 		CImage(const CImage &Src);
< 		~CImage();
< 		CImage &operator=(const CImage &Src);
< 		void Free();
< 		bool LoadFromFile(LPCWSTR pszFileName);
< 		bool LoadFromResource(HINSTANCE hinst,LPCWSTR pszName);
< 		bool LoadFromResource(HINSTANCE hinst,LPCTSTR pszName,LPCTSTR pszType);
< 		bool Create(int Width,int Height,int BitsPerPixel);
< 		bool CreateFromBitmap(HBITMAP hbm,HPALETTE hpal=NULL);
< 		bool CreateFromDIB(const BITMAPINFO *pbmi,const void *pBits);
< 		bool IsCreated() const;
< 		int GetWidth() const;
< 		int GetHeight() const;
< 		void Clear();
< 		friend CGdiPlus;
< 		friend class CCanvas;
< 	};
< 
< 	class CBrush {
< 		Gdiplus::SolidBrush *m_pBrush;
< 	public:
< 		CBrush();
< 		CBrush(BYTE r,BYTE g,BYTE b,BYTE a=255);
< 		CBrush(COLORREF Color);
< 		~CBrush();
< 		void Free();
< 		bool CreateSolidBrush(BYTE r,BYTE g,BYTE b,BYTE a=255);
< 		friend CGdiPlus;
< 	};
< 
< 	class CCanvas {
< 		Gdiplus::Graphics *m_pGraphics;
< 	public:
< 		CCanvas(HDC hdc);
< 		CCanvas(CImage *pImage);
< 		~CCanvas();
< 		bool Clear(BYTE r,BYTE g,BYTE b,BYTE a=255);
< 		friend CGdiPlus;
< 	};
< 
< 	enum GradientDirection {
< 		GRADIENT_DIRECTION_HORZ,
< 		GRADIENT_DIRECTION_VERT
< 	};
< 
< 	CGdiPlus();
< 	~CGdiPlus();
< 	bool Initialize();
< 	void Finalize();
< 	bool IsInitialized() const { return m_fInitialized; }
< 	bool DrawImage(CCanvas *pCanvas,CImage *pImage,int x,int y);
< 	bool DrawImage(CCanvas *pCanvas,int DstX,int DstY,int DstWidth,int DstHeight,
< 				   CImage *pImage,int SrcX,int SrcY,int SrcWidth,int SrcHeight,float Opacity=1.0f);
< 	bool FillRect(CCanvas *pCanvas,CBrush *pBrush,const RECT *pRect);
< 	bool FillGradient(CCanvas *pCanvas,COLORREF Color1,COLORREF Color2,
< 					  const RECT &Rect,GradientDirection Direction);
< 
< private:
< 	bool m_fInitialized;
< };
< 
< 
< #include <uxtheme.h>
< #include <vssym32.h>
< 
< class CUxTheme
< {
< 	HTHEME m_hTheme;
< #ifdef WINDOWS2000_SUPPORT
< 	HMODULE m_hLib;
< #endif
< 
< public:
< 	CUxTheme();
< 	~CUxTheme();
< 	bool Initialize();
< 	bool Open(HWND hwnd,LPCWSTR pszClassList);
< 	void Close();
< 	bool IsOpen() const;
< 	bool IsActive();
< 	bool DrawBackground(HDC hdc,int PartID,int StateID,const RECT *pRect);
< 	bool DrawBackground(HDC hdc,int PartID,int StateID,
< 						int BackgroundPartID,int BackgroundStateID,
< 						const RECT *pRect);
< 	bool DrawText(HDC hdc,int PartID,int StateID,LPCWSTR pszText,
< 				  DWORD TextFlags,const RECT *pRect);
< 	bool GetTextExtent(HDC hdc,int PartID,int StateID,LPCWSTR pszText,
< 					   DWORD TextFlags,RECT *pExtentRect);
< 	bool GetMargins(int PartID,int StateID,int PropID,MARGINS *pMargins);
< 	bool GetColor(int PartID,int StateID,int PropID,COLORREF *pColor);
< 	bool GetFont(int PartID,int StateID,int PropID,LOGFONT *pFont);
< 	bool GetInt(int PartID,int StateID,int PropID,int *pValue);
< 	bool GetPartSize(HDC hdc,int PartID,int StateID,SIZE *pSize);
< };
< 
diff TVTestStatusView_orig/Settings.cpp ./Settings.cpp
1,2c1,4
< #include "stdafx.h"
< #include "TVTest.h"
---
> #include <Windows.h>
> #include <Shlwapi.h>
> #include <tchar.h>
> #include "Util.h"
4a7
> #if 0
9a13
> #endif
11c15
< 
---
> #define lengthof _countof
diff TVTestStatusView_orig/StatusView.cpp ./StatusView.cpp
1,2c1,3
< #include "stdafx.h"
< #include "TVTest.h"
---
> #include <Windows.h>
> #include <WindowsX.h>
> #include "Util.h"
144,159d144
< void CStatusItem::DrawIcon(HDC hdc,const RECT *pRect,DrawUtil::CMonoColorBitmap &Bitmap,
< 						   int SrcX,int SrcY,int IconWidth,int IconHeight,bool fEnabled) const
< {
< 	if (hdc==NULL)
< 		return;
< 
< 	COLORREF cr=::GetTextColor(hdc);
< 	if (!fEnabled)
< 		cr=MixColor(cr,::GetBkColor(hdc));
< 	Bitmap.Draw(hdc,
< 				pRect->left+((pRect->right-pRect->left)-IconWidth)/2,
< 				pRect->top+((pRect->bottom-pRect->top)-IconHeight)/2,
< 				cr,SrcX,SrcY,IconWidth,IconHeight);
< }
< 
< 
374a360,363
> 			if (GetItemRectByIndex(m_HotItem,&rc)) {
> 				m_ItemList[m_HotItem]->OnMouseMove(x-rc.left,y);
> 			}
> 
376,378c365,367
< 				GetItemRectByIndex(m_HotItem,&rc);
< 				x-=rc.left;
< 				m_ItemList[m_HotItem]->OnMouseMove(x,y);
---
> 				//GetItemRectByIndex(m_HotItem,&rc);
> 				//x-=rc.left;
> 				//m_ItemList[m_HotItem]->OnMouseMove(x,y);
465a455,462
> 		if (m_HotItem>=0) {
> 			int x=GET_X_LPARAM(lParam),y=GET_Y_LPARAM(lParam);
> 			RECT rc;
> 
> 			GetItemRectByIndex(m_HotItem,&rc);
> 			x-=rc.left;
> 			m_ItemList[m_HotItem]->OnLButtonUp(x,y);
> 		}
646c643
< 		m_SingleText.Set(pszText);
---
> 		m_SingleText=pszText;
652c649
< 		m_SingleText.Clear();
---
> 		m_SingleText.clear();
935c932
< 		::DrawText(hdcDst,m_SingleText.Get(),-1,&rc,
---
> 		::DrawText(hdcDst,m_SingleText.c_str(),-1,&rc,
diff TVTestStatusView_orig/StatusView.h ./StatusView.h
5a6
> #include <string>
7d7
< #include "TsUtilClass.h"
34,35d33
< 	void DrawIcon(HDC hdc,const RECT *pRect,DrawUtil::CMonoColorBitmap &Bitmap,
< 				  int SrcX=0,int SrcY=0,int IconWidth=16,int IconHeight=16,bool fEnabled=true) const;
54a53
> 	virtual void OnLButtonUp(int x,int y) {}
144c143
< 	CDynamicString m_SingleText;
---
> 	std::basic_string<TCHAR> m_SingleText;
diff TVTestStatusView_orig/Theme.cpp ./Theme.cpp
1c1
< #include "stdafx.h"
---
> #include <Windows.h>
diff TVTestStatusView_orig/WindowUtil.cpp ./WindowUtil.cpp
1c1,2
< #include "stdafx.h"
---
> #include <Windows.h>
> #include <WindowsX.h>
